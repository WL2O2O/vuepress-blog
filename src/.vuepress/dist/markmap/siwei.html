<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.4"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"paragraph","depth":1,"payload":{"lines":[1,5]},"content":"title: 思维导图<br>\nshortTitle: JAVA SE思维导图<br>\nsticky: true<br>\ncategory:"},{"type":"bullet_list","depth":1,"payload":{"lines":[5,13]},"content":"","children":[{"type":"list_item","depth":2,"payload":{"lines":[5,7]},"content":"面经<br>\ntag:"},{"type":"list_item","depth":2,"payload":{"lines":[7,10]},"content":"Java SE<br>\ndescription: 自己总结的Java SE面试导图<br>\nhead:"},{"type":"list_item","depth":2,"payload":{"lines":[10,13]},"content":"","children":[{"type":"list_item","depth":3,"payload":{"lines":[10,11]},"content":"meta"},{"type":"list_item","depth":3,"payload":{"lines":[11,13]},"content":"name: keywords<br>\ncontent: Java,Java SE,Java基础,Java教程,Java程序员进阶之路,Java入门,教程,复盘Java基础知识,Java随笔,复盘Java基础知识, 一份详细的Java面试基础知识, 一篇文章搞懂Java SE"}]}]},{"type":"paragraph","depth":1,"payload":{"lines":[15,24]},"content":"<iframe\n  :src=\"$withBase('/思维导图.html')\"\n  width=\"100%\"\n  height=\"400\"\n  frameborder=\"0\"\n  scrolling=\"No\"\n  leftmargin=\"0\"\n  topmargin=\"0\"\n/>"},{"type":"heading","depth":1,"payload":{"lines":[25,26]},"content":"面试导图","children":[{"type":"heading","depth":2,"payload":{"lines":[27,28]},"content":"Java SE","children":[{"type":"heading","depth":3,"payload":{"lines":[29,30]},"content":"是什么（概念）","children":[{"type":"list_item","depth":4,"payload":{"lines":[31,32]},"content":"Java是一门面向对象的编程语言，继承了C<ins>的幼优点，舍弃了C</ins>的多继承与指针的难点，因此Java是一门功能强大且容易上手的编程语言。","children":[{"type":"list_item","depth":5,"payload":{"lines":[33,34]},"content":"Java是一门面向对象的编程语言，不仅吸收了C<ins>的优点，还舍弃了C</ins>的多继承与指针的难点，因此Java具有功能强大且容易上手的编程语言。"}]}]},{"type":"heading","depth":3,"payload":{"lines":[35,36]},"content":"怎么样（特点）","children":[{"type":"list_item","depth":4,"payload":{"lines":[37,38]},"content":"面向对象","children":[{"type":"list_item","depth":5,"payload":{"lines":[39,40]},"content":"封装、继承、多态"}]},{"type":"list_item","depth":4,"payload":{"lines":[41,42]},"content":"跨平台？原理","children":[{"type":"list_item","depth":5,"payload":{"lines":[43,44]},"content":"Write once，run anywhere"}]},{"type":"list_item","depth":4,"payload":{"lines":[45,46]},"content":"支持多线程","children":[{"type":"list_item","depth":5,"payload":{"lines":[47,48]},"content":"内置多线程机制，无需调用操作系统的多线程功能进行功能设计"}]},{"type":"list_item","depth":4,"payload":{"lines":[49,50]},"content":"编译与解释并存","children":[{"type":"list_item","depth":5,"payload":{"lines":[51,52]},"content":"高级编程语言按照程序的执行方式分为编译形和解释形，编译型就好比把外国文献先全部翻译再阅读，解释型就好比逐行翻译有，阅读后再翻译。为什么说Java是编译与解释并存？引文Java程序需要先编译成字节码.class文件，然后平台JVM将字节码解释成平台可识别的机器码，操作系统运行。","children":[{"type":"list_item","depth":6,"payload":{"lines":[53,54]},"content":"扩展：","children":[{"type":"list_item","depth":7,"payload":{"lines":[55,56]},"content":"动态类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[57,58]},"content":"只有在运行期间才会检查变量的数据类型，该类语言会在变量的第一次赋值时将数据类型记录下来。代表语言：Python、Ruby、PHP、JS"}]},{"type":"list_item","depth":7,"payload":{"lines":[59,60]},"content":"静态类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[61,62]},"content":"编译期间进行数据类型检查，不通过则无法运行。该类语言必须先声明数据类型，分配好内存空间。代表语言：C、C++、Java、Object-C"}]},{"type":"list_item","depth":7,"payload":{"lines":[63,64]},"content":"强类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[65,66]},"content":"含义：强制数据类型定义的语言，一旦变量声明，转换数据类型需要强制转换。代表语言：Java、C#、Python、Ruby、Object-C"}]},{"type":"list_item","depth":7,"payload":{"lines":[67,68]},"content":"弱类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[69,70]},"content":"含义：允许隐式类型转换，例如：int + float = float。代表语言：JS、PHP、C、C++"}]},{"type":"list_item","depth":7,"payload":{"lines":[71,72]},"content":"引申：编译型语言vs解释性语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[73,74]},"content":"编译型语言有一个专门的编译过程，优点：运行时无需再次编译，执行效率高；缺点：依赖编译器，跨平台性差。"},{"type":"list_item","depth":8,"payload":{"lines":[74,75]},"content":"解释性语言运行前无需编译，优点：运行时逐行解释再运行，跨平台性好；缺点：执行效率低。注：语言都是解释性语言。"}]}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[76,77]},"content":"JVM、JDK、JRE的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[78,79]},"content":"jdk包含jre、jre包含jvm"}]},{"type":"list_item","depth":4,"payload":{"lines":[80,81]},"content":"字节码？什么好处","children":[{"type":"list_item","depth":5,"payload":{"lines":[82,83]},"content":"字节码是Java程序经过编译之后产生的。class文件，可以直接被jvm识别并运行，从而能够跨平台运行"}]}]},{"type":"heading","depth":3,"payload":{"lines":[84,85]},"content":"基础语法","children":[{"type":"list_item","depth":4,"payload":{"lines":[86,87]},"content":"数据类型","children":[{"type":"list_item","depth":5,"payload":{"lines":[88,89]},"content":"基本数据类型","children":[{"type":"list_item","depth":6,"payload":{"lines":[90,91]},"content":"整型","children":[{"type":"list_item","depth":7,"payload":{"lines":[92,93]},"content":"byte、short、int、long"}]},{"type":"list_item","depth":6,"payload":{"lines":[94,95]},"content":"浮点型","children":[{"type":"list_item","depth":7,"payload":{"lines":[96,97]},"content":"float、double"}]},{"type":"list_item","depth":6,"payload":{"lines":[98,99]},"content":"字符型","children":[{"type":"list_item","depth":7,"payload":{"lines":[100,101]},"content":"char"}]},{"type":"list_item","depth":6,"payload":{"lines":[102,103]},"content":"布尔型","children":[{"type":"list_item","depth":7,"payload":{"lines":[104,105]},"content":"boolean"}]}]},{"type":"list_item","depth":5,"payload":{"lines":[106,107]},"content":"引用数据类型","children":[{"type":"list_item","depth":6,"payload":{"lines":[108,109]},"content":"class"},{"type":"list_item","depth":6,"payload":{"lines":[109,110]},"content":"interface"},{"type":"list_item","depth":6,"payload":{"lines":[110,111]},"content":"数组"}]},{"type":"list_item","depth":5,"payload":{"lines":[112,113]},"content":"类型转换","children":[{"type":"list_item","depth":6,"payload":{"lines":[114,115]},"content":"自动转换","children":[{"type":"list_item","depth":7,"payload":{"lines":[116,117]},"content":"小杯水可以倒进大杯子，大杯水倒进小杯子就可能会溢出。案例1：float num1 = 1.2，在Java中float浮点型类型变量的声明要在数字的末尾加上f或F，否则属于双精度double类型，下转上会造成精度损失，正确写法：float num1 = 1.2F。"}]},{"type":"list_item","depth":6,"payload":{"lines":[118,119]},"content":"强制转换","children":[{"type":"list_item","depth":7,"payload":{"lines":[120,121]},"content":"对于上述解决方案，还可以进行强制类型转换：float num = (float)1.1;  案例2：short num2 = 1； num2  = num2 + 1;此时编译器会进行报错，我们一般的解决办法是进行强转，或者：short num2 = 1;  num2 += 1,这其实其中num2 += 1，有隐含的强制类型转换。"}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[122,123]},"content":"自动拆箱/装箱","children":[{"type":"list_item","depth":5,"payload":{"lines":[124,126]},"content":"装箱：Integer i = 10，把整型10装箱为Integer<br>\n拆箱：把i再赋值给int，int n = i；"}]},{"type":"list_item","depth":4,"payload":{"lines":[127,128]},"content":"运算符与位运算","children":[{"type":"list_item","depth":5,"payload":{"lines":[129,130]},"content":"&amp;","children":[{"type":"list_item","depth":6,"payload":{"lines":[131,132]},"content":"逻辑与（短路与：全1为1,有0为0）","children":[{"type":"list_item","depth":7,"payload":{"lines":[133,138]},"content":"算法引申：逻辑与可以用来判断奇偶数、是否为2的n次方的数，奇数的二进制末尾肯定为1，偶数的二进制末尾一定是0。例如：7(D) = 111(B), 所以7&amp;1 == 0。<br>\n结论：<br>\npublic static boolean check(int m){<br>\nreturn (m&amp;1)==1;<br>\n}"}]}]},{"type":"list_item","depth":5,"payload":{"lines":[139,140]},"content":"&amp;&amp;","children":[{"type":"list_item","depth":6,"payload":{"lines":[141,143]},"content":"短路与运算：跟&amp;差别很大：<br>\na == 1 &amp;&amp; b == 2，如果a == 1不成立，那么直接短路，右边不计算，很多时候都会用到","children":[{"type":"list_item","depth":7,"payload":{"lines":[144,145]},"content":"引申：| 与||","children":[{"type":"list_item","depth":8,"payload":{"lines":[146,147]},"content":"逻辑或（|）和短路（||）的差别亦是如此"}]}]}]},{"type":"list_item","depth":5,"payload":{"lines":[148,149]},"content":"<ins>a和a</ins>","children":[{"type":"list_item","depth":6,"payload":{"lines":[150,151]},"content":"涉及到JVM的工作原理：对于a<ins>来说，先创建一个临时变量，然后自增加1，若进行a = i</ins>赋值，a取到的是临时变量的值。"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[152,153]},"content":"语句特点","children":[{"type":"list_item","depth":5,"payload":{"lines":[154,155]},"content":"switch（电闸原理）作用域","children":[{"type":"list_item","depth":6,"payload":{"lines":[156,159]},"content":"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。<br>\n从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。<br>\n从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。"}]},{"type":"list_item","depth":5,"payload":{"lines":[160,161]},"content":"break、continue、return"}]}]},{"type":"heading","depth":3,"payload":{"lines":[164,165]},"content":"面向对象","children":[{"type":"list_item","depth":4,"payload":{"lines":[166,167]},"content":"面向对象与面向过程","children":[{"type":"list_item","depth":5,"payload":{"lines":[168,169]},"content":"面向对象：纪传体史记","children":[{"type":"list_item","depth":6,"payload":{"lines":[170,171]},"content":"典例：Java，万物皆对象，Java自带了许多封装好的方法，方便我们调用。面向对象加强了代码的重用，屏蔽差异性。"}]},{"type":"list_item","depth":5,"payload":{"lines":[172,173]},"content":"面向过程：编年体左转","children":[{"type":"list_item","depth":6,"payload":{"lines":[174,175]},"content":"典例：C，对于每一个功能，需要编写函数进行一步一步的实现。使用的时候再一步一步调用。"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[176,177]},"content":"三大特性","children":[{"type":"list_item","depth":5,"payload":{"lines":[178,179]},"content":"封装","children":[{"type":"list_item","depth":6,"payload":{"lines":[180,181]},"content":"封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。"}]},{"type":"list_item","depth":5,"payload":{"lines":[182,183]},"content":"继承","children":[{"type":"list_item","depth":6,"payload":{"lines":[184,185]},"content":"新的类可以继承已有的类，Class A extends Class B,A拥有B的所有属性与方法，但是无法访问私有属性"}]},{"type":"list_item","depth":5,"payload":{"lines":[186,187]},"content":"多态","children":[{"type":"list_item","depth":6,"payload":{"lines":[188,189]},"content":"多态的体现就在于继承与接口，可以实现同一个方法speak()被不同类型的对象调用，但是根据对象的实际类型，会产生不同的行为。","children":[{"type":"list_item","depth":7,"payload":{"lines":[190,205]},"content":"class Animal{<br>\npublic void speak(){<br>\nSyetem.out.println(&quot;动物叫&quot;);<br>\n}<br>\n}<br>\nclass cat extends Animal{<br>\npublic void speak{<br>\nSyetem.out.println(&quot;cat叫&quot;);<br>\n}<br>\n}<br>\nclass dog extends Animal{<br>\npublic void speak{<br>\nSyetem.out.println(&quot;dog叫&quot;);<br>\n}<br>\n}"}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[206,207]},"content":"重载与重写的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[208,209]},"content":"都是实现多态的方式：重载也叫方法重载，是同方法名，有着不同的参数，实现了不同的行为方法的我实现，例如实现不同数据类型的运算。"}]},{"type":"list_item","depth":4,"payload":{"lines":[210,211]},"content":"访问修饰符的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[212,213]},"content":"访问修饰符：public、protected、private"}]},{"type":"list_item","depth":4,"payload":{"lines":[214,215]},"content":"this关键字"},{"type":"list_item","depth":4,"payload":{"lines":[215,216]},"content":"抽象类和接口的区别"},{"type":"list_item","depth":4,"payload":{"lines":[216,217]},"content":"成员变量与局部变量的区别"},{"type":"list_item","depth":4,"payload":{"lines":[217,218]},"content":"静态变量与实例变量的区别"},{"type":"list_item","depth":4,"payload":{"lines":[218,219]},"content":"静态方法与实例方法的区别"},{"type":"list_item","depth":4,"payload":{"lines":[219,220]},"content":"final、finally、finalize关键字的作用"},{"type":"list_item","depth":4,"payload":{"lines":[220,221]},"content":"==和equals的区别"},{"type":"list_item","depth":4,"payload":{"lines":[221,222]},"content":"hashCode与equals"},{"type":"list_item","depth":4,"payload":{"lines":[222,223]},"content":"Java是值传递还是引用传递"},{"type":"list_item","depth":4,"payload":{"lines":[223,224]},"content":"深拷贝与浅拷贝"},{"type":"list_item","depth":4,"payload":{"lines":[224,225]},"content":"Java创建对象有几种方式"}]},{"type":"heading","depth":3,"payload":{"lines":[226,227]},"content":"String"},{"type":"heading","depth":3,"payload":{"lines":[228,229]},"content":"Integer"},{"type":"heading","depth":3,"payload":{"lines":[230,231]},"content":"Object"},{"type":"heading","depth":3,"payload":{"lines":[232,233]},"content":"异常处理"},{"type":"heading","depth":3,"payload":{"lines":[234,235]},"content":"I/O"},{"type":"heading","depth":3,"payload":{"lines":[236,237]},"content":"序列化"},{"type":"heading","depth":3,"payload":{"lines":[238,239]},"content":"泛型"},{"type":"heading","depth":3,"payload":{"lines":[240,241]},"content":"注解"},{"type":"heading","depth":3,"payload":{"lines":[242,243]},"content":"反射"},{"type":"heading","depth":3,"payload":{"lines":[244,245]},"content":"JDK8新特性"},{"type":"heading","depth":3,"payload":{"lines":[246,247]},"content":"Lambdb表达式"},{"type":"heading","depth":3,"payload":{"lines":[248,249]},"content":"Optional"},{"type":"heading","depth":3,"payload":{"lines":[250,251]},"content":"Stream流"}]},{"type":"heading","depth":2,"payload":{"lines":[252,253]},"content":"Java集合框架"},{"type":"heading","depth":2,"payload":{"lines":[254,255]},"content":"Java并发编程"},{"type":"heading","depth":2,"payload":{"lines":[256,257]},"content":"JVM"},{"type":"heading","depth":2,"payload":{"lines":[258,259]},"content":"Spring"},{"type":"heading","depth":2,"payload":{"lines":[260,261]},"content":"Redis"},{"type":"heading","depth":2,"payload":{"lines":[262,263]},"content":"分布式"},{"type":"heading","depth":2,"payload":{"lines":[264,265]},"content":"RocketMQ"},{"type":"heading","depth":2,"payload":{"lines":[266,267]},"content":"计算机网络"},{"type":"heading","depth":2,"payload":{"lines":[268,269]},"content":"操作系统"},{"type":"heading","depth":2,"payload":{"lines":[270,271]},"content":"MySQL"},{"type":"heading","depth":2,"payload":{"lines":[272,273]},"content":"MyBatis"}]}],"payload":{}},{})</script>
</body>
</html>
