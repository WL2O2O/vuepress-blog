import{_ as a,X as i,Y as l,a2 as e}from"./framework-1ff68d8d.js";const r={},h=e('<h1 id="面试导图" tabindex="-1"><a class="header-anchor" href="#面试导图" aria-hidden="true">#</a> 面试导图</h1><h2 id="java-se" tabindex="-1"><a class="header-anchor" href="#java-se" aria-hidden="true">#</a> Java SE</h2><h3 id="是什么-概念" tabindex="-1"><a class="header-anchor" href="#是什么-概念" aria-hidden="true">#</a> 是什么（概念）</h3><ul><li><p>Java是一门面向对象的编程语言，继承了C++的幼优点，舍弃了C++的多继承与指针的难点，因此Java是一门功能强大且容易上手的编程语言。</p><ul><li>Java是一门面向对象的编程语言，不仅吸收了C++的优点，还舍弃了C++的多继承与指针的难点，因此Java具有功能强大且容易上手的编程语言。</li></ul></li></ul><h3 id="怎么样-特点" tabindex="-1"><a class="header-anchor" href="#怎么样-特点" aria-hidden="true">#</a> 怎么样（特点）</h3><ul><li><p>面向对象</p><ul><li>封装、继承、多态</li></ul></li><li><p>跨平台？原理</p><ul><li>Write once，run anywhere</li></ul></li><li><p>支持多线程</p><ul><li>内置多线程机制，无需调用操作系统的多线程功能进行功能设计</li></ul></li><li><p>编译与解释并存</p><ul><li><p>高级编程语言按照程序的执行方式分为编译形和解释形，编译型就好比把外国文献先全部翻译再阅读，解释型就好比逐行翻译有，阅读后再翻译。为什么说Java是编译与解释并存？引文Java程序需要先编译成字节码.class文件，然后平台JVM将字节码解释成平台可识别的机器码，操作系统运行。</p><ul><li><p>扩展：</p><ul><li><p>动态类型语言</p><ul><li>只有在运行期间才会检查变量的数据类型，该类语言会在变量的第一次赋值时将数据类型记录下来。代表语言：Python、Ruby、PHP、JS</li></ul></li><li><p>静态类型语言</p><ul><li>编译期间进行数据类型检查，不通过则无法运行。该类语言必须先声明数据类型，分配好内存空间。代表语言：C、C++、Java、Object-C</li></ul></li><li><p>强类型语言</p><ul><li>含义：强制数据类型定义的语言，一旦变量声明，转换数据类型需要强制转换。代表语言：Java、C#、Python、Ruby、Object-C</li></ul></li><li><p>弱类型语言</p><ul><li>含义：允许隐式类型转换，例如：int + float = float。代表语言：JS、PHP、C、C++</li></ul></li><li><p>引申：编译型语言vs解释性语言</p><ul><li>编译型语言有一个专门的编译过程，优点：运行时无需再次编译，执行效率高；缺点：依赖编译器，跨平台性差。</li><li>解释性语言运行前无需编译，优点：运行时逐行解释再运行，跨平台性好；缺点：执行效率低。注：语言都是解释性语言。</li></ul></li></ul></li></ul></li></ul></li><li><p>JVM、JDK、JRE的区别</p><ul><li>jdk包含jre、jre包含jvm</li></ul></li><li><p>字节码？什么好处</p><ul><li>字节码是Java程序经过编译之后产生的。class文件，可以直接被jvm识别并运行，从而能够跨平台运行</li></ul></li></ul><h3 id="基础语法" tabindex="-1"><a class="header-anchor" href="#基础语法" aria-hidden="true">#</a> 基础语法</h3><ul><li><p>数据类型</p><ul><li><p>基本数据类型</p><ul><li><p>整型</p><ul><li>byte、short、int、long</li></ul></li><li><p>浮点型</p><ul><li>float、double</li></ul></li><li><p>字符型</p><ul><li>char</li></ul></li><li><p>布尔型</p><ul><li>boolean</li></ul></li></ul></li><li><p>引用数据类型</p><ul><li>class</li><li>interface</li><li>数组</li></ul></li><li><p>类型转换</p><ul><li><p>自动转换</p><ul><li>小杯水可以倒进大杯子，大杯水倒进小杯子就可能会溢出。案例1：float num1 = 1.2，在Java中float浮点型类型变量的声明要在数字的末尾加上f或F，否则属于双精度double类型，下转上会造成精度损失，正确写法：float num1 = 1.2F。</li></ul></li><li><p>强制转换</p><ul><li>对于上述解决方案，还可以进行强制类型转换：float num = (float)1.1; 案例2：short num2 = 1； num2 = num2 + 1;此时编译器会进行报错，我们一般的解决办法是进行强转，或者：short num2 = 1; num2 += 1,这其实其中num2 += 1，有隐含的强制类型转换。</li></ul></li></ul></li></ul></li><li><p>自动拆箱/装箱</p><ul><li>装箱：Integer i = 10，把整型10装箱为Integer 拆箱：把i再赋值给int，int n = i；</li></ul></li><li><p>运算符与位运算</p><ul><li><p>&amp;</p><ul><li><p>逻辑与（短路与：全1为1,有0为0）</p><ul><li>算法引申：逻辑与可以用来判断奇偶数、是否为2的n次方的数，奇数的二进制末尾肯定为1，偶数的二进制末尾一定是0。例如：7(D) = 111(B), 所以7&amp;1 == 0。 结论： public static boolean check(int m){ return (m&amp;1)==1; }</li></ul></li></ul></li><li><p>&amp;&amp;</p><ul><li><p>短路与运算：跟&amp;差别很大： a == 1 &amp;&amp; b == 2，如果a == 1不成立，那么直接短路，右边不计算，很多时候都会用到</p><ul><li><p>引申：| 与||</p><ul><li>逻辑或（|）和短路（||）的差别亦是如此</li></ul></li></ul></li></ul></li><li><p>++a和a++</p><ul><li>涉及到JVM的工作原理：对于a++来说，先创建一个临时变量，然后自增加1，若进行a = i++赋值，a取到的是临时变量的值。</li></ul></li></ul></li><li><p>语句特点</p><ul><li><p>switch（电闸原理）作用域</p><ul><li>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。 从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。 从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。</li></ul></li><li><p>break、continue、return</p><ul><li></li></ul></li></ul></li></ul><h3 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h3><ul><li><p>面向对象与面向过程</p><ul><li><p>面向对象：纪传体史记</p><ul><li>典例：Java，万物皆对象，Java自带了许多封装好的方法，方便我们调用。面向对象加强了代码的重用，屏蔽差异性。</li></ul></li><li><p>面向过程：编年体左转</p><ul><li>典例：C，对于每一个功能，需要编写函数进行一步一步的实现。使用的时候再一步一步调用。</li></ul></li></ul></li><li><p>三大特性</p><ul><li><p>封装</p><ul><li>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</li></ul></li><li><p>继承</p><ul><li>新的类可以继承已有的类，Class A extends Class B,A拥有B的所有属性与方法，但是无法访问私有属性</li></ul></li><li><p>多态</p><ul><li><p>多态的体现就在于继承与接口，可以实现同一个方法speak()被不同类型的对象调用，但是根据对象的实际类型，会产生不同的行为。</p><ul><li>class Animal{ public void speak(){ Syetem.out.println(&quot;动物叫&quot;); } } class cat extends Animal{ public void speak{ Syetem.out.println(&quot;cat叫&quot;); } } class dog extends Animal{ public void speak{ Syetem.out.println(&quot;dog叫&quot;); } }</li></ul></li></ul></li></ul></li><li><p>重载与重写的区别</p><ul><li>都是实现多态的方式：重载也叫方法重载，是同方法名，有着不同的参数，实现了不同的行为方法的我实现，例如实现不同数据类型的运算。</li></ul></li><li><p>访问修饰符的区别</p><ul><li>访问修饰符：public、protected、private</li></ul></li><li><p>this关键字</p></li><li><p>抽象类和接口的区别</p></li><li><p>成员变量与局部变量的区别</p></li><li><p>静态变量与实例变量的区别</p></li><li><p>静态方法与实例方法的区别</p></li><li><p>final、finally、finalize关键字的作用</p></li><li><p>==和equals的区别</p></li><li><p>hashCode与equals</p></li><li><p>Java是值传递还是引用传递</p></li><li><p>深拷贝与浅拷贝</p></li><li><p>Java创建对象有几种方式</p></li></ul><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><h3 id="integer" tabindex="-1"><a class="header-anchor" href="#integer" aria-hidden="true">#</a> Integer</h3><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h3><h3 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h3><h3 id="i-o" tabindex="-1"><a class="header-anchor" href="#i-o" aria-hidden="true">#</a> I/O</h3><h3 id="序列化" tabindex="-1"><a class="header-anchor" href="#序列化" aria-hidden="true">#</a> 序列化</h3><h3 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h3><h3 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h3><h3 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h3><h3 id="jdk8新特性" tabindex="-1"><a class="header-anchor" href="#jdk8新特性" aria-hidden="true">#</a> JDK8新特性</h3><h3 id="lambdb表达式" tabindex="-1"><a class="header-anchor" href="#lambdb表达式" aria-hidden="true">#</a> Lambdb表达式</h3><h3 id="optional" tabindex="-1"><a class="header-anchor" href="#optional" aria-hidden="true">#</a> Optional</h3><h3 id="stream流" tabindex="-1"><a class="header-anchor" href="#stream流" aria-hidden="true">#</a> Stream流</h3><h2 id="java集合框架" tabindex="-1"><a class="header-anchor" href="#java集合框架" aria-hidden="true">#</a> Java集合框架</h2><h2 id="java并发编程" tabindex="-1"><a class="header-anchor" href="#java并发编程" aria-hidden="true">#</a> Java并发编程</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2><h2 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> Spring</h2><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><h2 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式" aria-hidden="true">#</a> 分布式</h2><h2 id="rocketmq" tabindex="-1"><a class="header-anchor" href="#rocketmq" aria-hidden="true">#</a> RocketMQ</h2><h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h2><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h2><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h2><h2 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> MyBatis</h2>',34),d=[h];function u(n,t){return i(),l("div",null,d)}const s=a(r,[["render",u],["__file","思维导图.html.vue"]]);export{s as default};
