<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta name="keywords" content="Java,Java SE,Java基础,Java教程,Java程序员进阶之路,Java入门,教程,java数组,数组,复盘Java基础知识,Java随笔,跟着老杜学Java,Java程序员进阶之路"><meta property="og:url" content="https://wlei224.gitee.io/cainiao/javaessay.html"><meta property="og:site_name" content="CS_GUIDER"><meta property="og:title" content="Java随笔"><meta property="og:description" content="是平时的学习记录"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-06-09T10:10:24.000Z"><meta property="article:author" content="WLei224"><meta property="article:tag" content="Java笔记"><meta property="article:modified_time" content="2023-06-09T10:10:24.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Java随笔","image":[""],"dateModified":"2023-06-09T10:10:24.000Z","author":[{"@type":"Person","name":"WLei224","url":"/aboutguider/"}]}</script><meta name="robots" content="all"><meta name="author" content="WLei224"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="apple-mobile-web-app-capable" content="yes"><script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?5230ac143650bf5eb3c14f3fb9b1d3ec";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
      </script><link rel="stylesheet" href="//at.alicdn.com/t/font_3180624_7cy10l7jqqh.css"><link rel="icon" href="http://images.rl0206.love/202304221329083.ico"><link rel="icon" href="/logo.png" type="image/png" sizes="512x512"><link rel="icon" href="/logo.png" type="image/png" sizes="192x192"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/logo.png"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/logo.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>Java随笔 | CS_GUIDER</title><meta name="description" content="是平时的学习记录">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-bdb84084.css" as="style"><link rel="stylesheet" href="/assets/style-bdb84084.css">
    <link rel="modulepreload" href="/assets/app-51c8bbd8.js"><link rel="modulepreload" href="/assets/framework-b0c8e9b4.js"><link rel="modulepreload" href="/assets/javaessay.html-63676bd4.js"><link rel="modulepreload" href="/assets/javaessay.html-5bb8719d.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button type="button" class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="brand"><img class="logo" src="/favicon.ico" alt="CS_GUIDER"><!----><span class="site-name hide-in-pad">CS_GUIDER</span></a><!--]--><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><!--[--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/blog.html" class="nav-link" aria-label="博客"><span class="font-icon icon iconfont icon-home" style=""></span>博客<!----></a></div><div class="nav-item hide-in-mobile"><a href="/collection/" class="nav-link" aria-label="CS之路"><span class="font-icon icon iconfont icon-branch" style=""></span>CS之路<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zhishixingqiu/" class="nav-link" aria-label="知识星球"><span class="font-icon icon iconfont icon-discover" style=""></span>知识星球<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guider/" class="nav-link" aria-label="CS规划"><span class="font-icon icon iconfont icon-guide" style=""></span>CS规划<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="宝藏资源"><span class="title"><span class="font-icon icon iconfont icon-like" style=""></span>宝藏资源</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/pdf/README.md" class="nav-link" aria-label="PDF天堂"><span class="font-icon icon iconfont icon-java" style=""></span>PDF天堂<!----></a></li><li class="dropdown-item"><a href="/app/" class="nav-link" aria-label="APP整合"><span class="font-icon icon iconfont icon-hot" style=""></span>APP整合<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://csguider.icu/hexoblog" rel="noopener noreferrer" target="_blank" aria-label="Hexo博客" class="nav-link"><span class="font-icon icon iconfont icon-heading" style=""></span>Hexo博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/WLei224/WLei224.git" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/cainiao/" class="nav-link sidebar-link sidebar-page" aria-label="菜鸟日记"><span class="font-icon icon iconfont icon-alias" style=""></span>菜鸟日记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/%E4%BF%AE%E4%BB%99%E5%89%8D%E8%A8%80.html" class="nav-link sidebar-link sidebar-page" aria-label="菜鸟修仙第一🗡"><!---->菜鸟修仙第一🗡<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/abstractandinterface.html" class="nav-link sidebar-link sidebar-page" aria-label="抽象类与接口"><!---->抽象类与接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/article.html" class="nav-link sidebar-link sidebar-page" aria-label="为什么说祖国完全统一进程不可阻挡"><!---->为什么说祖国完全统一进程不可阻挡<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/collection.html" class="nav-link sidebar-link sidebar-page" aria-label="浅析Java集合框架"><!---->浅析Java集合框架<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/DMDatabase.html" class="nav-link sidebar-link sidebar-page" aria-label="DMDatabase"><!---->DMDatabase<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/DNS.html" class="nav-link sidebar-link sidebar-page" aria-label="头歌平台DNS服务器配置"><!---->头歌平台DNS服务器配置<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/Educoder.html" class="nav-link sidebar-link sidebar-page" aria-label="头歌实践平台笔记分享"><!---->头歌实践平台笔记分享<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git常用命令"><!---->Git常用命令<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/hellovuepress.html" class="nav-link sidebar-link sidebar-page" aria-label="网站搭建过程记录"><!---->网站搭建过程记录<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/cainiao/javaessay.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Java随笔"><!---->Java随笔<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#《方法》" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="《方法》"><!---->《方法》<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#定义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="定义："><!---->定义：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#方法结构定义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法结构定义："><!---->方法结构定义：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#方法优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法优化："><!---->方法优化：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#方法重载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法重载"><!---->方法重载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#方法递归" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法递归"><!---->方法递归<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#递归实例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="递归实例"><!---->递归实例<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#《代码的包装与封装》" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="《代码的包装与封装》"><!---->《代码的包装与封装》<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#《认识面向对象》" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="《认识面向对象》"><!---->《认识面向对象》<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#类与对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类与对象"><!---->类与对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#浅析类与对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="浅析类与对象："><!---->浅析类与对象：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#对象的创建" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象的创建："><!---->对象的创建：<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#java变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Java变量"><!---->Java变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#常用的48个关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="常用的48个关键字"><!---->常用的48个关键字<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#关键字顺序排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="关键字顺序排序："><!---->关键字顺序排序：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#用户自定义方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="用户自定义方法"><!---->用户自定义方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#tips-如果是静态方法-那么调用时就不用new关键字来创建对象来调用了" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）"><!---->（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#那么-java中如何进行创建对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="那么，Java中如何进行创建对象？"><!---->那么，Java中如何进行创建对象？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#访问权限控制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="访问权限控制"><!---->访问权限控制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_1-修饰类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.修饰类"><!---->1.修饰类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_2-修饰类的方法和变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.修饰类的方法和变量"><!---->2.修饰类的方法和变量<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#代码初始化块" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="代码初始化块"><!---->代码初始化块<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#补充-什么叫构造方法-有参-无参" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="补充：什么叫构造方法？有参？无参？"><!---->补充：什么叫构造方法？有参？无参？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#方法的继承" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法的继承"><!---->方法的继承<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#抽象类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="抽象类"><!---->抽象类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#敲黑板知识点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="敲黑板知识点："><!---->敲黑板知识点：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#抽象方法的应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="抽象方法的应用场景"><!---->抽象方法的应用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="接口"><!---->接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#内部类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="内部类"><!---->内部类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="总结"><!---->总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="关键字"><!---->关键字<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_1-static" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.static"><!---->1.static<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#静态代码块" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="静态代码块"><!---->静态代码块<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_2-this" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.this"><!---->2.this<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_01、-指向当前对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="01、 指向当前对象"><!---->01、 指向当前对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_02、调用当前类的方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="02、调用当前类的方法"><!---->02、调用当前类的方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_03、调用当前类的构造方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="03、调用当前类的构造方法"><!---->03、调用当前类的构造方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_04、作为参数在方法中传递-没看懂" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="*04、作为参数在方法中传递（没看懂"><!---->*04、作为参数在方法中传递（没看懂<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_05、作为参数在构造方法中传递" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="05、作为参数在构造方法中传递"><!---->05、作为参数在构造方法中传递<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_06、作为方法的返回值" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="06、作为方法的返回值"><!---->06、作为方法的返回值<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_3-super" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.super"><!---->3.super<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_4-final" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.final"><!---->4.final<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_5-instanceof" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.instanceof"><!---->5.instanceof<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#不可变对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="*不可变对象"><!---->*不可变对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_01、什么是不可变类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="01、什么是不可变类？"><!---->01、什么是不可变类？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_02、常见的不可变类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="02、常见的不可变类"><!---->02、常见的不可变类<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#可变参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="*可变参数"><!---->*可变参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#泛型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="泛型"><!---->泛型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#什么是泛型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="什么是泛型"><!---->什么是泛型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#注解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="注解"><!---->注解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#枚举-enum" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="枚举（enum）"><!---->枚举（enum）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#单例-。。。" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="单例：。。。"><!---->单例：。。。<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#反射" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="反射"><!---->反射<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#集合框架-容器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="集合框架（容器）"><!---->集合框架（容器）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_01、list" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="01、List"><!---->01、List<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_02、set" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="02、Set"><!---->02、Set<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_03、queue" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="03、Queue"><!---->03、Queue<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_04、map" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="04、Map"><!---->04、Map<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#浅析arraylist-动态数组" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="浅析ArrayList（动态数组）"><!---->浅析ArrayList（动态数组）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#浅析linkedlist-链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="浅析linkedList（链表）"><!---->浅析linkedList（链表）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#arraylist和linkedlist的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="ArrayList和LinkedList的区别"><!---->ArrayList和LinkedList的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#java中的iterator和iterable区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Java中的Iterator和Iterable区别"><!---->Java中的Iterator和Iterable区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#fail-fast" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="fail-fast"><!---->fail-fast<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#hashmap" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="HashMap"><!---->HashMap<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#关于字符编码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="关于字符编码："><!---->关于字符编码：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_1-ascii" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1）ASCII"><!---->1）ASCII<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_2-unicode" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2）Unicode"><!---->2）Unicode<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_3-utf" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3）UTF"><!---->3）UTF<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_4-gb-2312" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4）GB 2312"><!---->4）GB 2312<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_5-gbk" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5）GBK"><!---->5）GBK<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#_6-char" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6）char"><!---->6）char<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/cainiao/javaessay.html#什么是classpath" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="什么是classpath?"><!---->什么是classpath?<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/cainiao/Linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux常用命令"><!---->Linux常用命令<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/MyLanqiaoNote.html" class="nav-link sidebar-link sidebar-page" aria-label="蓝桥杯笔记"><!---->蓝桥杯笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/mysql.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL冷知识"><!---->MySQL冷知识<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/netty.html" class="nav-link sidebar-link sidebar-page" aria-label="浅析Netty"><!---->浅析Netty<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/object.html" class="nav-link sidebar-link sidebar-page" aria-label="浅析JavaObject"><!---->浅析JavaObject<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/cainiao/transaction.html" class="nav-link sidebar-link sidebar-page" aria-label="什么是事务"><!---->什么是事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Java随笔</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="/aboutguider/" target="_blank" rel="noopener noreferrer">WLei224</a></span><span property="author" content="WLei224"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-14T08:54:23.000Z"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category1 clickable" role="navigation">菜鸟日记</span><!--]--><meta property="articleSection" content="菜鸟日记"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag5 clickable" role="navigation">Java笔记</span><!--]--><meta property="keywords" content="Java笔记"></span><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 19969 字</span><meta property="wordCount" content="19969"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 67 分钟</span><meta property="timeRequired" content="PT67M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#《方法》" class="router-link-active router-link-exact-active toc-link level2">《方法》</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#定义" class="router-link-active router-link-exact-active toc-link level3">定义：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#方法结构定义" class="router-link-active router-link-exact-active toc-link level3">方法结构定义：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#方法优化" class="router-link-active router-link-exact-active toc-link level3">方法优化：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#方法重载" class="router-link-active router-link-exact-active toc-link level3">方法重载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#方法递归" class="router-link-active router-link-exact-active toc-link level3">方法递归</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#递归实例" class="router-link-active router-link-exact-active toc-link level3">递归实例</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#《代码的包装与封装》" class="router-link-active router-link-exact-active toc-link level2">《代码的包装与封装》</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#《认识面向对象》" class="router-link-active router-link-exact-active toc-link level2">《认识面向对象》</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#类与对象" class="router-link-active router-link-exact-active toc-link level2">类与对象</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#浅析类与对象" class="router-link-active router-link-exact-active toc-link level3">浅析类与对象：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#对象的创建" class="router-link-active router-link-exact-active toc-link level3">对象的创建：</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#java变量" class="router-link-active router-link-exact-active toc-link level2">Java变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#常用的48个关键字" class="router-link-active router-link-exact-active toc-link level2">常用的48个关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#关键字顺序排序" class="router-link-active router-link-exact-active toc-link level2">关键字顺序排序：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#用户自定义方法" class="router-link-active router-link-exact-active toc-link level2">用户自定义方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#tips-如果是静态方法-那么调用时就不用new关键字来创建对象来调用了" class="router-link-active router-link-exact-active toc-link level2">（tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#那么-java中如何进行创建对象" class="router-link-active router-link-exact-active toc-link level2">那么，Java中如何进行创建对象？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#访问权限控制" class="router-link-active router-link-exact-active toc-link level2">访问权限控制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_1-修饰类" class="router-link-active router-link-exact-active toc-link level3">1.修饰类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_2-修饰类的方法和变量" class="router-link-active router-link-exact-active toc-link level3">2.修饰类的方法和变量</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#代码初始化块" class="router-link-active router-link-exact-active toc-link level2">代码初始化块</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#补充-什么叫构造方法-有参-无参" class="router-link-active router-link-exact-active toc-link level2">补充：什么叫构造方法？有参？无参？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#方法的继承" class="router-link-active router-link-exact-active toc-link level2">方法的继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#抽象类" class="router-link-active router-link-exact-active toc-link level2">抽象类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#敲黑板知识点" class="router-link-active router-link-exact-active toc-link level3">敲黑板知识点：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#抽象方法的应用场景" class="router-link-active router-link-exact-active toc-link level3">抽象方法的应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#接口" class="router-link-active router-link-exact-active toc-link level2">接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#内部类" class="router-link-active router-link-exact-active toc-link level2">内部类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#总结" class="router-link-active router-link-exact-active toc-link level3">总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#关键字" class="router-link-active router-link-exact-active toc-link level2">关键字</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_1-static" class="router-link-active router-link-exact-active toc-link level3">1.static</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#静态代码块" class="router-link-active router-link-exact-active toc-link level3">静态代码块</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_2-this" class="router-link-active router-link-exact-active toc-link level3">2.this</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_01、-指向当前对象" class="router-link-active router-link-exact-active toc-link level3">01、 指向当前对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_02、调用当前类的方法" class="router-link-active router-link-exact-active toc-link level3">02、调用当前类的方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_03、调用当前类的构造方法" class="router-link-active router-link-exact-active toc-link level3">03、调用当前类的构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_04、作为参数在方法中传递-没看懂" class="router-link-active router-link-exact-active toc-link level3">*04、作为参数在方法中传递（没看懂</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_05、作为参数在构造方法中传递" class="router-link-active router-link-exact-active toc-link level3">05、作为参数在构造方法中传递</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_06、作为方法的返回值" class="router-link-active router-link-exact-active toc-link level3">06、作为方法的返回值</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_3-super" class="router-link-active router-link-exact-active toc-link level3">3.super</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_4-final" class="router-link-active router-link-exact-active toc-link level3">4.final</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_5-instanceof" class="router-link-active router-link-exact-active toc-link level3">5.instanceof</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#不可变对象" class="router-link-active router-link-exact-active toc-link level2">*不可变对象</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_01、什么是不可变类" class="router-link-active router-link-exact-active toc-link level3">01、什么是不可变类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_02、常见的不可变类" class="router-link-active router-link-exact-active toc-link level3">02、常见的不可变类</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#可变参数" class="router-link-active router-link-exact-active toc-link level2">*可变参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#泛型" class="router-link-active router-link-exact-active toc-link level2">泛型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#什么是泛型" class="router-link-active router-link-exact-active toc-link level3">什么是泛型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#注解" class="router-link-active router-link-exact-active toc-link level2">注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#枚举-enum" class="router-link-active router-link-exact-active toc-link level2">枚举（enum）</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#单例-。。。" class="router-link-active router-link-exact-active toc-link level3">单例：。。。</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#反射" class="router-link-active router-link-exact-active toc-link level2">反射</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#集合框架-容器" class="router-link-active router-link-exact-active toc-link level2">集合框架（容器）</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_01、list" class="router-link-active router-link-exact-active toc-link level3">01、List</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_02、set" class="router-link-active router-link-exact-active toc-link level3">02、Set</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_03、queue" class="router-link-active router-link-exact-active toc-link level3">03、Queue</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_04、map" class="router-link-active router-link-exact-active toc-link level3">04、Map</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#浅析arraylist-动态数组" class="router-link-active router-link-exact-active toc-link level3">浅析ArrayList（动态数组）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#浅析linkedlist-链表" class="router-link-active router-link-exact-active toc-link level3">浅析linkedList（链表）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#arraylist和linkedlist的区别" class="router-link-active router-link-exact-active toc-link level3">ArrayList和LinkedList的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#java中的iterator和iterable区别" class="router-link-active router-link-exact-active toc-link level3">Java中的Iterator和Iterable区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#fail-fast" class="router-link-active router-link-exact-active toc-link level3">fail-fast</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#hashmap" class="router-link-active router-link-exact-active toc-link level3">HashMap</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#关于字符编码" class="router-link-active router-link-exact-active toc-link level2">关于字符编码：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_1-ascii" class="router-link-active router-link-exact-active toc-link level2">1）ASCII</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_2-unicode" class="router-link-active router-link-exact-active toc-link level2">2）Unicode</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_3-utf" class="router-link-active router-link-exact-active toc-link level2">3）UTF</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_4-gb-2312" class="router-link-active router-link-exact-active toc-link level2">4）GB 2312</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_5-gbk" class="router-link-active router-link-exact-active toc-link level2">5）GBK</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#_6-char" class="router-link-active router-link-exact-active toc-link level2">6）char</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/cainiao/javaessay.html#什么是classpath" class="router-link-active router-link-exact-active toc-link level2">什么是classpath?</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><ul><li><p><em>写在前面：</em></p><ul><li>【免责声明：】本笔记来源自互联，是笔者结合自己的理解进行整理归纳发表在hexo博客只便于个人学习使用，若涉及到侵权，请联系我，谢谢！</li><li>个人博客地址：<a href="https://csguider.icu/" target="_blank" rel="noopener noreferrer">https://csguider.icu/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></li><li><p>写作背景:</p><ul><li>笔者是一名大三在校生，目前正在努力学习Java方向，笔记书写于22年暑假期间，虽然起步有点晚，但是每天都在坚持，只要努力，光一定会shine向我的。</li></ul></li></ul><h1 id="参考学习网站" tabindex="-1"><a class="header-anchor" href="#参考学习网站" aria-hidden="true">#</a> 参考学习网站</h1><p><a href="https://www.pdai.tech/md/java/basic/java-basic-x-generic.html" target="_blank" rel="noopener noreferrer">Java全栈知识体系<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>——泛型</p><p><a href="https://tobebetterjavaer.com/" target="_blank" rel="noopener noreferrer">Java程序员进阶之路<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>——沉默王二</p><h1 id="老杜java笔记" tabindex="-1"><a class="header-anchor" href="#老杜java笔记" aria-hidden="true">#</a> 老杜Java笔记</h1><p><strong>P58</strong> 具体的命名规范： 1、顾名思义； 2、驼峰原则：一高一低：例如：PowerNodeNotes； 3、类名、接口名首字母大写 ； 变量名方法名首字母小写； 常量名全部大写，单词之间用_下划线连接：USER_AGE;</p><p><strong>P60</strong> 关键字： int、long、float...public static void boolean private protect 蓝色字体、小写显示</p><p><strong>P63</strong> 提取帮助文档：也就是写在/** 这里面的注释信息。 * *@author *@version */ javadoc -d+文件夹名（文件夹绝对路径）+（需要提取的信息）+Java源文件 例如：javadoc -d javaapi -author -version VarTest02.java</p><p><strong>P70</strong> 1，变量的分类： public class Test{ int i;//全局变量 public static void main(String[] args){ int j;局部变量 } }</p><p>2，变量的作用域：即有效范围（出了大括号就处于非作用域）！</p><p><strong>P72</strong> 标识符可以标志什么： 类名、方法名、常量、变量、接口名</p><p>记录所有编程出现的错误，记录错误~！</p><p><strong>P113</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Homework1</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
		i<span class="token operator">=</span>i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//运行结果为10！</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//Java和C++源代码运行结果不一样，C++结果为11、Java为10.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因：编译器原理不一样，其中Java的代码可以理解为一下三行： （在Java语言中i++，这种表达式在执行的时候，会提前将i变量找一个存储空间临时存储，不同于C++） int temp=i; i++; i=temp; 因此！！！可以理解为：分号之后++再加一</p><p><strong>P116</strong> 接收键盘输入：</p><p>在Java中则怎么接收键盘信息呢？ 第一种形式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//创建一个键盘扫描器对象(s为对象名，上下对应)</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Scanner</span> s <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Scanner</span> s <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token keyword">int</span> i<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	

<span class="token class-name">String</span> str <span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//接收用户的输入，从键盘上接受一个int类型的数据、</span>
<span class="token comment">//i变量有值了，并且i变量中保存的这个值是用户输入的数字。</span>
<span class="token comment">//i变量就是接收键盘数据的</span>
<span class="token keyword">int</span> i<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;您输入的数字是：&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> j<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;您输入的数字是：&quot;</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//字符串类型</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
其他数据类型类似
其中println<span class="token operator">:</span>print为打印、ln为换行。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一种形式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>	<span class="token comment">//idea可以自动引入</span>
<span class="token comment">//创建键盘扫描器对象</span>
<span class="token class-name">Scanner</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token operator">+</span><span class="token string">&quot;+&quot;</span><span class="token operator">+</span>num2<span class="token operator">+</span><span class="token string">&quot;=&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>头歌实践教学平台项目案例练习：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//什么是类、怎么创建类：</span>
<span class="token keyword">package</span> <span class="token namespace">step1</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token doc-comment comment">/********** Begin **********/</span>
		<span class="token comment">//创建Dog对象</span>
		<span class="token comment">//设置Dog对象的属性</span>
        <span class="token class-name">Dog</span> wuhuarou <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		wuhuarou<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;五花肉&quot;</span><span class="token punctuation">;</span>
        wuhuarou<span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token string">&quot;棕色&quot;</span><span class="token punctuation">;</span>
        wuhuarou<span class="token punctuation">.</span>variety<span class="token operator">=</span><span class="token string">&quot;阿拉斯加&quot;</span><span class="token punctuation">;</span>
		<span class="token comment">//输出小狗的属性</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;名字：&quot;</span> <span class="token operator">+</span> wuhuarou<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot;，毛色：&quot;</span> <span class="token operator">+</span> wuhuarou<span class="token punctuation">.</span>color<span class="token operator">+</span> <span class="token string">&quot;，品种：&quot;</span> <span class="token operator">+</span>wuhuarou<span class="token punctuation">.</span>variety <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//调用方法</span>
        wuhuarou<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        wuhuarou<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token doc-comment comment">/********** End **********/</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//在这里定义Dog类</span>
<span class="token doc-comment comment">/********** Begin **********/</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">,</span>color<span class="token punctuation">,</span>variety<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;啃骨头&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;叼着骨头跑&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token doc-comment comment">/********** End **********/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于质数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">step2</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FindZhiShu</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		   <span class="token comment">/*
		     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；
		     使用print进行打印同时被打印输出的质数后加上一个空格，
		     以便于与平台提供的结果格式保持一致！
            */</span>   
		   <span class="token doc-comment comment">/**********begin**********/</span>
            a<span class="token operator">:</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>		<span class="token comment">//此循环遍历次数较多，若对代码效率有要求，则可进一步改进代码：如下：</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">continue</span> a<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
           <span class="token doc-comment comment">/**********end**********/</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
		<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>改进之后的代码<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token keyword">package</span> <span class="token namespace">step2</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FindZhiShu</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		   <span class="token comment">/*
		     打印输出质数的时候务必按照如下格式：System.out.print(质数+&quot; &quot;)；
		     使用print进行打印同时被打印输出的质数后加上一个空格，
		     以便于与平台提供的结果格式保持一致！
            */</span>   
		   <span class="token doc-comment comment">/**********begin**********/</span>

	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;2 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//因为2是特殊的质数，又因下面循环会自动跳过偶数，因此先将2打印出来。</span>
	        a<span class="token operator">:</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
	            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	                <span class="token keyword">continue</span> a<span class="token punctuation">;</span>		<span class="token comment">//此方法运用了给循环做标记，以此可以对continue和break进行明确的命令指示。</span>
	            <span class="token punctuation">}</span>
	            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	       <span class="token doc-comment comment">/**********end**********/</span>	
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="《方法》" tabindex="-1"><a class="header-anchor" href="#《方法》" aria-hidden="true">#</a> 《方法》</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义：</h3><p>是可以完成某一个特定的功能，并且可被重复利用。</p><p>在面向对象的语言中，函数称为方法，类似于C语言总的函数。方法写在类体中，可以写在main函数前后，不分顺序，因为main函数为执行入口。</p><h3 id="方法结构定义" tabindex="-1"><a class="header-anchor" href="#方法结构定义" aria-hidden="true">#</a> 方法结构定义：</h3><p>【修饰符列表】 返回值类型 方法名 （形式参数列表）{</p><p>​ 方法体;</p><p>}</p><p>注意：</p><p>【】符号叫中括号、以上中括号里的内容表是不是必须的，是可以选择的，方法体由Java语句构成；</p><p>关于修饰符列表：</p><p>也不是必须的，目前可写成public static（称为静态方法）</p><p>break与return的区别：</p><p>break：用来终止一个switch语句和距离最近的循环</p><p>return：用来终止一个方法。</p><h3 id="方法优化" tabindex="-1"><a class="header-anchor" href="#方法优化" aria-hidden="true">#</a> 方法优化：</h3><p>例题：编写一个方法，输出大于某个正整数n的最小的质数（思考：这个方法应该取什么名字，这个方法的形参是什么，返回值类型是什么？）</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code> public class Homework2{
    public static void main(String[] args){
        //假设目前系统给定一个正整数n，n为5
        int n = 7;
        //输出大于5的最小质数
        while(true){
            n++;
			//需要一个判断是否为质数的方法。。
            if(isZhiShu(n)){				
                System.out.print(&quot;最小质数是&quot;+n);
                break;
            }
        }
    }

	//该方法返回一个Boolean字符，用于main方法中的if判断语句。
	public static boolean isZhiShu(int num){
		//判断num是否为质数
		//可以利用循环取余的方法来判断是否可以整除除1和本身的数字
		for(int i = 2; i &lt; num;i++ ){
			if(num%i==0){
				return false;
			}
		}
		//return语句容易写在for循环里面，写在里面判断不完全
		//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断
		return true;
	}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编程思路以及改进版：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Homework2</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        
        <span class="token comment">//以下代码省略，新增打印质数的方法</span>
		<span class="token comment">/*
		//假设目前系统给定一个正整数n，n为5
        int n = 7;
		//输出大于5的最小质数
        while(true){
            n++;
			//需要一个判断是否为质数的方法。。
            if(isZhiShu(n)){				
                System.out.print(&quot;最小质数是&quot;+n);
                break;
            }
        }
		*/</span>
		
		<span class="token comment">//引入用户输入的数据</span>
		<span class="token class-name">Scanner</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> num <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//直接调用打印质数的方法</span>
		<span class="token function">printZhiShu</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">}</span>
	<span class="token comment">//代码不够精简，还可以在main（）中调用打印输出质数的方法</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printZhiShu</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
		
		<span class="token comment">//while循环仍可精简，但是精简之后不易理解，代码如下：</span>
		<span class="token comment">/*		
		while(isZhiShu(num)){
		}
		System.out.print(&quot;最小质数是&quot;+num);
		*/</span>

		<span class="token comment">/*while(true){
    		//需要一个判断是否为质数的方法。。
            if(isZhiShu(++num)){				
                System.out.print(&quot;最小质数是&quot;+num);
                break;
            }
		}	
		*/</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isZhiShu</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;最小质数是&quot;</span><span class="token operator">+</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
	<span class="token punctuation">}</span>

	<span class="token comment">//该方法返回一个Boolean字符，用于main方法中的if判断语句。</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isZhiShu</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//判断num是否为质数</span>
		<span class="token comment">//可以利用循环取余的方法来判断是否可以整除除1和本身的数字</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//return语句容易写在for循环里面，写在里面判断不完全</span>
		<span class="token comment">//return之所以写在外面是因为要让循环执行完毕，执行完毕才可以正确判断</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">//以上代码为编程思路，以下为精简代码：</span>
<span class="token comment">/*
import java.util.Scanner;
public class Homework2{
    public static void main(String[] args){
		Scanner s = new Scanner(System.in);
		int num = s.nextInt();

		printZhiShu(num);
    }

	public static void printZhiShu(int num){
		while(!isZhiShu(++num)){
		}
		System.out.print(&quot;最小质数是&quot;+num);
	}

	public static boolean isZhiShu(int num){
		for(int i = 2; i &lt; num;i++ ){
			if(num%i==0){
				return false;
			}
		}
		return true;
	}

}
*/</span>
 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h3><p>同一个类中：方法名相同，形参个数或者类型不同。</p><p>优点：代码整齐美观，记忆方法名较少。</p><p>含义：就是可以定义多个相同名字的方法（例如：public static int sum(int a,int b)和public static int sum(long a,long b)）</p><p>原理：Java编译器会自动识别方法名，若方法名相同，则进行参数类型匹配，所以名方法重载。</p><p>怎么判断：方法名相同、形参类型不同、形参个数不同、形参顺序不同</p><h3 id="方法递归" tabindex="-1"><a class="header-anchor" href="#方法递归" aria-hidden="true">#</a> 方法递归</h3><p>含义：方法调用自己的方法！</p><p>典例：从前有座山，山里有个和尚说：{从前有座山，山里有个和尚说}：{从前有座山，山里有个和尚说}——递归。。。</p><p>老杜这样说：</p><p>方法递归？</p><p>​ 1、什么是方法递归？</p><p>​ 方法自己调用自己，这就是方法递归。</p><p>​ 2、当递归时程序没有结束条件，一定会发生：</p><p>​ 栈内存溢出错误：StackOverflowError</p><p>​ 所以：递归必须要有结束条件。（这是一个非常重要的知识点。）</p><p>​ JVM发生错误之后一定会推出JVM。</p><p>​ 3、递归假设是有结束条件的，就一定不会发生栈内存溢出吗？</p><p>​ 假设这个结束条件时对的，是合法的，递归有时候也会出现栈内存溢出的错误。</p><p>​ 因为有时候，可能递归的太深，栈内存不够（因为一直在压栈）</p><p>​ 4、不建议在实际的开发中使用递归，，能用for循环while循环代替的尽量使用循环来做，因为循环的效率较高，耗费内存少。递归耗费的内存较多，另外递归若使用不当，则会导致JVM的死掉。</p><p>​ （极少数的情况下是必须要用递归的。）</p><p>​ 所以：递归还是要认真学习的！</p><p>老杜讲经验：</p><p>​ 如果遇到了栈内存溢出，怎么调bug?</p><p>​ 第一步：</p><p>​ 先检查递归的结束条件对不对。如果不对，则进一步修改，直到正确。</p><p>​ 第二步：</p><p>​ 如果假设条件没问题，这个时候需要手动调整JVM的栈内存初始大小（通过命令行适当调大。）</p><p>​ 第三步：</p><p>​ 如果还会栈内存溢出，则继续调大。（Java -X 这个命令可以查看调整堆栈大小的参数。具体格式如下图所示：）</p><p>老杜栈内存溢出图：</p><figure><img src="http://images.rl0206.love/202305070014339.png" alt="image-20220715183512822" tabindex="0" loading="lazy"><figcaption>image-20220715183512822</figcaption></figure><p>如何指 定栈内存大小：</p><figure><img src="http://images.rl0206.love/202305070014342.png" alt="image-20220715184629869" tabindex="0" loading="lazy"><figcaption>image-20220715184629869</figcaption></figure><h3 id="递归实例" tabindex="-1"><a class="header-anchor" href="#递归实例" aria-hidden="true">#</a> 递归实例</h3><p>题目：计算1~ 10的和。</p><p>不用递归思路：写一个for循环方法，直接调用。</p><p>用递归思路：（方法调用打法）</p><figure><img src="http://images.rl0206.love/202305070014343.png" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="《代码的包装与封装》" tabindex="-1"><a class="header-anchor" href="#《代码的包装与封装》" aria-hidden="true">#</a> 《代码的包装与封装》</h2><p>封装及使用方法：</p><figure><img src="http://images.rl0206.love/202305070014344.png" alt="image-20220715170415137" tabindex="0" loading="lazy"><figcaption>image-20220715170415137</figcaption></figure><h2 id="《认识面向对象》" tabindex="-1"><a class="header-anchor" href="#《认识面向对象》" aria-hidden="true">#</a> 《认识面向对象》</h2><p>面向对象与面向过程：</p><p>​ 面向过程的优缺点：</p><p>​ 缺点：（高度耦合）</p><p>​ 面向过程的程序的每一个功能之间都是因果关系，因为A所以B，AB联合成一个子模块，然后模块与模块之间形成因果关系。因此任何一个功能之间出现问题，就会导致另一出现问题。 这就是高度耦合！（耦合度就是粘连程度）</p><p>​ 耦合度高导致扩展力差（主板集成显卡）</p><p>​ 耦合度低导致扩展力强（独立下显卡，螺栓与螺母等）</p><p>​ 优点：（快速开发）</p><p>​ 对于小型项目，可以直接通过因果关系来写代码。不需要前期对象的提取、模型的建立，可以直接干活，从而实现功能。</p><p>什么是面向对象的开发模式？</p><p>​ 万物皆为对象，人眼看到的是各个对象之间的联系，更符合人类的思维方式。因此，面向对象在成为主流。</p><p>如何判断面向过程和面向对象？</p><p>​ 可以通过耦合度等判断。</p><p>三个过程：</p><p>​ OOA--&gt;OOD--&gt;OOP</p><p>​ 分析 设计 编程</p><p>三大特征：</p><p>封装、继承、多态。（任何一个面向对象的编程语言都包括这三个特征。）</p><h2 id="类与对象" tabindex="-1"><a class="header-anchor" href="#类与对象" aria-hidden="true">#</a> 类与对象</h2><h3 id="浅析类与对象" tabindex="-1"><a class="header-anchor" href="#浅析类与对象" aria-hidden="true">#</a> 浅析类与对象：</h3><p>​ 类是一个集合，包含对象的特征，是特征的总结。</p><p>​ 而对象是真实存在的，万物皆可对象。</p><p>在Java语言中，要想得到对象，必须先定义类，，，对象是通过类创建的。</p><p>​ 例如：先定义人类，才可以定义魏磊。哈哈哈哈。</p><p>重要概念：</p><p>​ 《实例化》</p><p>​ 含义：通过类创建对象的过程叫做实例化。</p><p>​ 《实例》</p><p>​ 含义：对象又被称为实例。</p><p>（此处补充类与对象的图）</p><p>​ 《抽象》</p><p>​ 含义：魏磊到人类的过程程为抽象。</p><p>​ 类--【实例化】--&gt;对象（实例）</p><p>​ 对象--【抽象】--&gt;类</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class 明星类{
    /*
    类 = 属性 + 方法

	属性来源于状态； （名词）	数据是以数据形式存在的，所以只能存放在变量中。		即属性即变量。

	方法来源于动作； （动词）
	*/
    //属性
    int 身高;
    int 体重;
    
    //方法
    打篮球（）{
        
    }
    学习（）{
        
    }
    
    


}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对象的创建" tabindex="-1"><a class="header-anchor" href="#对象的创建" aria-hidden="true">#</a> 对象的创建：</h3><p>​ &quot;没对象，new一个&quot;</p><p>​ 创建对象语法：XueSheng s1 = new XueSheng();</p><p>​ XueSheng s1 = new XueSheng()；此时此刻就相当于 ：int i = 1；</p><pre><code>										XueSheng:数据类型
</code></pre><p>​ s1:变量名</p><p>​ new:运算符</p><p>​ XueSheng:类名</p><h2 id="java变量" tabindex="-1"><a class="header-anchor" href="#java变量" aria-hidden="true">#</a> Java变量</h2><p>变量的分类：</p><p>1局部变量</p><p>2成员变量</p><p>3静态变量</p><p>4常量 （要求大写）</p><p>​</p><h1 id="java进阶之路笔记" tabindex="-1"><a class="header-anchor" href="#java进阶之路笔记" aria-hidden="true">#</a> Java进阶之路笔记</h1><h2 id="常用的48个关键字" tabindex="-1"><a class="header-anchor" href="#常用的48个关键字" aria-hidden="true">#</a> 常用的48个关键字</h2><p><a href="https://tobebetterjavaer.com/about-the-author/" target="_blank" rel="noopener noreferrer">沉默王二<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>2021年10月22日Java核心Java大约 4 分钟</p><hr><p>“二哥，就我之前学过的这些 Java 代码中，有 public、static、void、main 等等，它们应该都是关键字吧？”三妹的脸上泛着甜甜的笑容，我想她在学习 Java 方面已经变得越来越自信了。</p><p>“是的，三妹。Java 中的关键字可不少呢！你一下子可能记不了那么多，不过，先保留个印象吧，对以后的学习会很有帮助。”</p><p>PS：按照首字母的自然顺序排列。</p><ol><li><strong>abstract：</strong> 用于声明抽象类，以及抽象方法。</li><li><strong>boolean：</strong> 用于将变量声明为布尔值类型，只有 true 和 false 两个值。</li><li><strong>break：</strong> 用于中断循环或 switch 语句。</li><li><strong>byte：</strong> 用于声明一个可以容纳 8 个比特的变量。</li><li><strong>case：</strong> 用于在 switch 语句中标记条件的值。</li><li><strong>catch：</strong> 用于捕获 try 语句中的异常。</li><li><strong>char：</strong> 用于声明一个可以容纳无符号 16 位比特的 <a href="https://mp.weixin.qq.com/s/pNQjlXOivIgO3pbYc0GnpA" target="_blank" rel="noopener noreferrer">Unicode 字符open in new window<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的变量。</li><li><strong>class：</strong> 用于声明一个类。</li><li><strong>continue：</strong> 用于继续下一个循环，可以在指定条件下跳过其余代码。</li><li><strong>default：</strong> 用于指定 switch 语句中除去 case 条件之外的默认代码块。</li><li><strong>do：</strong> 通常和 while 关键字配合使用，do 后紧跟循环体。</li><li><strong>double：</strong> 用于声明一个可以容纳 64 位浮点数的变量。</li><li><strong>else：</strong> 用于指示 if 语句中的备用分支。</li><li><strong>enum：</strong> 用于定义一组固定的常量（枚举）。</li><li><strong>extends：</strong> 用于指示一个类是从另一个类或接口继承的。</li><li><strong>final：</strong> 用于指示该变量是不可更改的。</li><li><strong>finally：</strong> 和 <code>try-catch</code> 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</li><li><strong>float：</strong> 用于声明一个可以容纳 32 位浮点数的变量。</li><li><strong>for：</strong> 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</li><li><strong>if：</strong> 用于指定条件，如果条件为真，则执行对应代码。</li><li><strong>implements：</strong> 用于实现接口。</li><li><strong>import：</strong> 用于导入对应的类或者接口。</li><li><strong>instanceof：</strong> 用于判断对象是否属于某个类型（class）。</li><li><strong>int：</strong> 用于声明一个可以容纳 32 位带符号的整数变量。</li><li><strong>interface：</strong> 用于声明接口。</li><li><strong>long：</strong> 用于声明一个可以容纳 64 位整数的变量。</li><li><strong>native：</strong> 用于指定一个方法是通过调用本机接口（非 Java）实现的。</li><li><strong>new：</strong> 用于创建一个新的对象。</li><li><strong>null：</strong> 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</li><li><strong>package：</strong> 用于声明类所在的包。</li><li><strong>private：</strong> 一个访问权限修饰符，表示方法或变量只对当前类可见。</li><li><strong>protected：</strong> 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。</li><li><strong>public：</strong> 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。<code>main()</code> 方法必须声明为 public。</li><li><strong>return：</strong> 用于在代码执行完成后返回（一个值）。</li><li><strong>short：</strong> 用于声明一个可以容纳 16 位整数的变量。</li><li><strong>static：</strong> 表示该变量或方法是静态变量或静态方法。</li><li><strong>strictfp：</strong> 并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</li><li><strong>super：</strong> 可用于调用父类的方法或者字段。</li><li><strong>switch：</strong> 通常用于三个（以上）的条件判断。</li><li><strong>synchronized：</strong> 用于指定多线程代码中的同步方法、变量或者代码块。</li><li><strong>this：</strong> 可用于在方法或构造函数中引用当前对象。</li><li><strong>throw：</strong> 主动抛出异常。</li><li><strong>throws：</strong> 用于声明异常。</li><li><strong>transient：</strong> 修饰的字段不会被序列化。</li><li><strong>try：</strong> 于包裹要捕获异常的代码块。</li><li><strong>void：</strong> 用于指定方法没有返回值。</li><li><strong>volatile：</strong> 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</li><li><strong>while：</strong> 如果循环次数不固定，建议使用 while 循环。</li></ol><h2 id="关键字顺序排序" tabindex="-1"><a class="header-anchor" href="#关键字顺序排序" aria-hidden="true">#</a> <strong>关键字顺序排序</strong>：</h2><p>byte&lt;short(char)&lt;int&lt;long&lt;float&lt;doublepackage step2;</p><h2 id="用户自定义方法" tabindex="-1"><a class="header-anchor" href="#用户自定义方法" aria-hidden="true">#</a> <strong>用户自定义方法</strong></h2><h2 id="tips-如果是静态方法-那么调用时就不用new关键字来创建对象来调用了" tabindex="-1"><a class="header-anchor" href="#tips-如果是静态方法-那么调用时就不用new关键字来创建对象来调用了" aria-hidden="true">#</a> （tips：如果是静态方法，那么调用时就不用new关键字来创建对象来调用了）</h2><p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findEvenOdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">&quot; 是偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">&quot; 是奇数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法名叫做 <code>findEvenOdd</code>，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p><p>方法被定义好后，如何被调用呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@author</span> 微信搜「沉默王二」，回复关键字 PDF
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EvenOddDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">findEvenOdd</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">findEvenOdd</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">findEvenOdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">&quot; 是偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">&quot; 是奇数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>main()</code> 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 <code>findEvenOdd()</code>。</p><p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p><h2 id="那么-java中如何进行创建对象" tabindex="-1"><a class="header-anchor" href="#那么-java中如何进行创建对象" aria-hidden="true">#</a> 那么，Java中如何进行创建对象？</h2><p>创建对象的四种方式：</p><p>以下是四种方式创建对象的示例代码：</p><ul><li>使用new关键字创建新对象</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person(&quot;Tom&quot;, 30);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用反射机制创建新对象</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class&lt;?&gt; clazz = Person.class;
        Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class);
        Person person = (Person) constructor.newInstance(&quot;Tom&quot;, 30);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用clone机制创建新对象</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Person implements Cloneable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Person person1 = new Person(&quot;Tom&quot;, 30);
        Person person2 = (Person) person1.clone();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用序列化机制创建新对象</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Person person1 = new Person(&quot;Tom&quot;, 30);

        // 将person1对象序列化成字节数组
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(person1);

        // 将字节数组反序列化成person2对象
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        Person person2 = (Person) ois.readObject();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四种方式都可以用来创建新对象，选择哪种方式取决于具体的需求和场景。需要注意的是，使用反射和序列化机制创建对象可能会对性能带来一定的影响，<strong>因此在需要高性能的场景下，最好使用new或clone机制创建对象。</strong></p><h2 id="访问权限控制" tabindex="-1"><a class="header-anchor" href="#访问权限控制" aria-hidden="true">#</a> 访问权限控制</h2><h3 id="_1-修饰类" tabindex="-1"><a class="header-anchor" href="#_1-修饰类" aria-hidden="true">#</a> <strong>1.修饰类</strong></h3><ul><li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li><li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li></ul><h3 id="_2-修饰类的方法和变量" tabindex="-1"><a class="header-anchor" href="#_2-修饰类的方法和变量" aria-hidden="true">#</a> <strong>2.修饰类的方法和变量</strong></h3><ul><li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li><li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li><li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li><li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li></ul><h2 id="代码初始化块" tabindex="-1"><a class="header-anchor" href="#代码初始化块" aria-hidden="true">#</a> 代码初始化块</h2><p>三个规则：</p><ul><li>类实例化的时候执行代码初始化块；</li><li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li><li>代码初始化块里的执行顺序是从前到后的。</li></ul><h2 id="补充-什么叫构造方法-有参-无参" tabindex="-1"><a class="header-anchor" href="#补充-什么叫构造方法-有参-无参" aria-hidden="true">#</a> 补充：什么叫构造方法？有参？无参？</h2><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class StudentDemo {
    public static void main(String[] args) {
       
        // 类名称 对象名 = new 类名称();
        Student stu1 = new Student();           //无参构造方法执行
        Student stu2 = new Student(&quot;张三&quot;,23);   //全参构造方法执行
        //赋值
        stu1.setName(&quot;李四&quot;);
        stu1.setAge(23);
       
        //对象名.成员变量名；
        System.out.println(&quot;姓名：&quot;+stu1.getName()+&quot;，年龄：&quot;+ stu1.getAge());
        System.out.println(&quot;姓名：&quot;+stu2.getName()+&quot;，年龄：&quot;+ stu2.getAge());
    }

}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="方法的继承" tabindex="-1"><a class="header-anchor" href="#方法的继承" aria-hidden="true">#</a> 方法的继承</h2><p>关键字：extend，super（用于继承父类）</p><p>“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”</p><p><strong>知识拓展：</strong></p><p>什么是@Overwide?</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>是伪代码<span class="token punctuation">,</span>表示重写<span class="token punctuation">(</span>当然不写也可以<span class="token punctuation">)</span>，不过写上有如下好处<span class="token operator">:</span>
<span class="token number">1</span>、可以当注释用<span class="token punctuation">,</span>方便阅读；
<span class="token number">2</span>、编译器可以给你验证<span class="token annotation punctuation">@Override</span>下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写<span class="token annotation punctuation">@Override</span>，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。
 
举例：在重写父类的onCreate时，在方法前面加上<span class="token annotation punctuation">@Override</span> 系统可以帮你检查方法的正确性。
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span> savedInstanceState<span class="token punctuation">)</span>

<span class="token punctuation">{</span>……<span class="token punctuation">.</span><span class="token punctuation">}</span>
这种写法是正确的，如果你写成：

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">oncreate</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span> savedInstanceState<span class="token punctuation">)</span>
<span class="token punctuation">{</span>……<span class="token punctuation">.</span><span class="token punctuation">}</span>
编译器会报如下错误：<span class="token class-name">The</span> method <span class="token function">oncreate</span><span class="token punctuation">(</span><span class="token class-name">Bundle</span><span class="token punctuation">)</span> of type <span class="token class-name">HelloWorld</span> must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加<span class="token annotation punctuation">@Override</span>，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><h3 id="敲黑板知识点" tabindex="-1"><a class="header-anchor" href="#敲黑板知识点" aria-hidden="true">#</a> 敲黑板知识点：</h3><p><strong>写在前面：</strong></p><p>什么是抽象？抽象的含义？</p><p>​ 抽象是不确定的、不具体的概念或事物。在Java中的抽象类，是指需要在子类中通过方法扩展来实现新的方法。</p><p>**关键字：**abstract</p><p><strong>语句格式：</strong></p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>abstract class AbstractPlayer {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>命名规则：</strong></p><p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的。</p><p><strong>Tips：</strong></p><p>抽象类是不能实例化的，尝试通过 <code>new</code> 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p><p>虽然抽象类不能实例化，但可以有子类。子类通过 <code>extends</code> 关键字来继承抽象类。就像下面这样。</p><p>Demo code:</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class BasketballPlayer extends AbstractPlayer {
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>抽象的方法不能定义在普通类中。否则会在类和方法处出现两个报错。</p><p>错误提示。第一处在类级别上，提示“这个类必须通过 <code>abstract</code> 关键字定义”，见下图。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-02.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/abstract-03.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>But,抽象类中既可以定义抽象方法、也可以普通方法。</strong></p><h3 id="抽象方法的应用场景" tabindex="-1"><a class="header-anchor" href="#抽象方法的应用场景" aria-hidden="true">#</a> 抽象方法的应用场景</h3><p><strong>第一种场景</strong>。</p><p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中有一个普通的方法 <code>sleep()</code>，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p><p>Demo:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractPlayer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;运动员也要休息而不是挑战极限&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类 <code>BasketballPlayer</code> 继承了 <code>AbstractPlayer</code> 类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">BasketballPlayer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractPlayer</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就拥有了 <code>sleep()</code> 方法。<code>BasketballPlayer </code>的对象可以直接调用父类的 <code>sleep() </code>方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">BasketballPlayer</span> basketballPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasketballPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
basketballPlayer<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如此，就实现了代码的复用。</p><p><strong>第二种场景</strong>。</p><p>当我们需要在抽象类中定义好 <code>API</code>，然后在子类中扩展实现的时候就可以使用抽象类。比如说，<code>AbstractPlayer</code> 抽象类中定义了一个抽象方法 <code>play()</code>，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p><p><strong>知识拓展：</strong></p><p>什么是API？</p><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。&quot;</p><p><strong>抽象类实例：</strong></p><p>读取大小写helloworld：</p><p><a href="">https://tobebetterjavaer.com/oo/abstract.html</a></p><h2 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h2><p>关键字：</p><p>interface</p><p>语法格式：</p><p>public interface jiekou1</p><p>class A extends B implements jiekou1,jiekou2,jiekou3</p><p>小结论：</p><ul><li>接口中允许定义变量</li><li>接口中允许定义抽象方法</li><li>接口中允许定义静态方法（Java 8 之后）</li><li>接口中允许定义默认方法（Java 8 之后）</li></ul><p>除此之外，我们还应该知道：</p><p>1）接口不允许直接实例化，否则编译器会报错。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/object-class/interface-04.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>需要定义一个类去实现接口，见下例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Computer</span> <span class="token keyword">implements</span> <span class="token class-name">Electronic</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getElectricityUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再实例化。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>Electronic e = new Computer();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>知识点拓展：</p><p>JAVA中extends 与implements有啥区别？</p><ol><li>在类的声明中，通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。 extends 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用</li><li>extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口 来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 比如 class A extends B implements C,D,E</li></ol><p><a href="https://blog.csdn.net/android_lover2014/article/details/52176814" target="_blank" rel="noopener noreferrer">(56条消息) Java之implements_小白study的博客-CSDN博客_implements<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>作业：多态与重载</p><p>​ 构造与重载</p><p>​ 抽象类与接口？</p><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h2><p><strong>== = = = = = = <a href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">内部类<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>（四种内部类详解）= = = = = = = ==</strong></p><p><strong>一、基本介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点,同时也是重点,后面看底层源码时,有大量的内部类.</strong><strong>如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类 定义在成员位置 (1) 成员内部类 (2)静态内部类</strong></p><p>在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。</p><p><strong>二、基本语法</strong><strong>class Outer{ //外部类 class Inner{ //内部类 } } class Other{ //外部其他类 }</strong></p><p>三、分类</p><p>一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。</p><p>定义在外部类的局部位置上(如方法内): 1)局部内部类(有类名) 2)匿名内部类(没有类名，重点!!!)</p><p>定义在外部类的成员位置上: 1)成员内部类(没用static修饰) 2)静态内部类（使用static修饰)</p><p><strong>1.成员内部类：</strong></p><p>成员内部类可以无限制访问外部类的所有成员属性。</p><p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class Wanger {
    int age = 18;
    private String name = &quot;沉默王二&quot;;
    static double money = 1;

    public Wanger () {
        new Wangxiaoer().print();
    }

    class Wangxiaoer {
        int age = 81;

        public void print() {
            System.out.println(name);
            System.out.println(money);
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p><p><strong>2.局部内部类</strong></p><p><strong>3.匿名内部类</strong></p><p><strong>4.静态内部类</strong></p><p>第一，静态内部类不能访问外部类的所有成员变量；</p><p>第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</p><p>第三，外部类不能声明为 static。”</p><p>“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-08.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>为什么要使用内部类？</p><p>在《Think in java》中有这样一句话：</p><blockquote><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote><p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p><p>使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p><ul><li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li><li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li><li>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li></ul><h2 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字" aria-hidden="true">#</a> 关键字</h2><h3 id="_1-static" tabindex="-1"><a class="header-anchor" href="#_1-static" aria-hidden="true">#</a> 1.static</h3><p><strong>static的作用</strong></p><p>“static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”</p><p>demo：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class Counter {
    int count = 0;

    Counter() {
        count++;
        System.out.println(count);
    }

    public static void main(String args[]) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();
    }
}
/*
我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class StaticCounter {
    static int count = 0;

    StaticCounter() {
        count++;
        System.out.println(count);
    }

    public static void main(String args[]) {
        StaticCounter c1 = new StaticCounter();
        StaticCounter c2 = new StaticCounter();
        StaticCounter c3 = new StaticCounter();
    }
}
/*
简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>warnning:</p><p>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-03.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>static的特点：</p><ul><li>静态方法属于这个类而不是这个类的对象；</li></ul><p>​ （因为静态方法不用类的实例化，所以直接通过类来调用，不通过类的实例来调用，因此不应通过对象调用）</p><ul><li>调用静态方法的时候不需要创建这个类的对象；</li><li>静态方法可以访问静态变量。</li></ul><p>那么问题来了，为什么main方法是静态的，这就涉及到Java的编译器JVM了，为了代码简洁与方便调用，main函数作为程序的入口，所以设为静态更为合适。</p><p>二哥这么说：</p><p><code>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。</code></p><p>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/19-06.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>综上所述（由上可得）：</p><p>一些函数基本上都是静态的。</p><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块" aria-hidden="true">#</a> 静态代码块</h3><p>“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”</p><p>“就像下面这串代码。”</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticBlock</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;静态代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;main 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“静态代码块通常用来初始化一些静态变量，它会优先于 <code>main()</code> 方法执行。”</p><h3 id="_2-this" tabindex="-1"><a class="header-anchor" href="#_2-this" aria-hidden="true">#</a> 2.this</h3><p>this除了可以指向当前方法或者构造函数的对象，还可以完成以下工作：</p><ul><li>调用当前类的方法；</li><li><code>this()</code> 可以调用当前类的构造方法；</li><li>this 可以作为参数在方法中传递；</li><li>this 可以作为参数在构造方法中传递；</li><li>this 可以作为方法的返回值，返回当前类的对象。</li></ul><h3 id="_01、-指向当前对象" tabindex="-1"><a class="header-anchor" href="#_01、-指向当前对象" aria-hidden="true">#</a> 01、 指向当前对象</h3><p><strong>demo</strong>：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>WithoutThisStudent(String name, int age) {
        name = name;
        age = age;
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>伪代码运行结果：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>null	0

null	0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更改之后的demo:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">WithThisStudent</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行正确√</p><h3 id="_02、调用当前类的方法" tabindex="-1"><a class="header-anchor" href="#_02、调用当前类的方法" aria-hidden="true">#</a> 02、调用当前类的方法</h3><p>“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中，<code>method2()</code> 在调用 <code>method1()</code> 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到。”</p><h3 id="_03、调用当前类的构造方法" tabindex="-1"><a class="header-anchor" href="#_03、调用当前类的构造方法" aria-hidden="true">#</a> 03、调用当前类的构造方法</h3><p>调用无参的constructor</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvokeConstrutor</span> <span class="token punctuation">{</span>
    <span class="token class-name">InvokeConstrutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">InvokeConstrutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">InvokeConstrutor</span> invokeConstrutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvokeConstrutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“也可以在无参构造方法中使用 <code>this()</code> 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvokeParamConstrutor</span> <span class="token punctuation">{</span>
    <span class="token class-name">InvokeParamConstrutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">InvokeParamConstrutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">InvokeParamConstrutor</span> invokeConstrutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvokeParamConstrutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>warning：</p><p>“不过，需要注意的是，<code>this()</code> 必须放在构造方法的第一行，否则就报错了。”</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/keywords/20-01.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_04、作为参数在方法中传递-没看懂" tabindex="-1"><a class="header-anchor" href="#_04、作为参数在方法中传递-没看懂" aria-hidden="true">#</a> *04、作为参数在方法中传递（没看懂</h3><h3 id="_05、作为参数在构造方法中传递" tabindex="-1"><a class="header-anchor" href="#_05、作为参数在构造方法中传递" aria-hidden="true">#</a> 05、作为参数在构造方法中传递</h3><h3 id="_06、作为方法的返回值" tabindex="-1"><a class="header-anchor" href="#_06、作为方法的返回值" aria-hidden="true">#</a> 06、作为方法的返回值</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThisAsMethodResult</span> <span class="token punctuation">{</span>
    <span class="token class-name">ThisAsMethodResult</span> <span class="token function">getThisAsMethodResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">ThisAsMethodResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThisAsMethodResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“<code>getThisAsMethodResult()</code> 方法返回了 this 关键字，指向的就是 <code>new ThisAsMethodResult()</code> 这个对象，所以可以紧接着调用 <code>out()</code> 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”</p><h3 id="_3-super" tabindex="-1"><a class="header-anchor" href="#_3-super" aria-hidden="true">#</a> 3.super</h3><p>“super 关键字的用法主要有三种。”</p><ul><li>指向父类对象；</li><li>调用父类的方法；</li><li><code>super()</code> 可以调用父类的构造方法。</li></ul><h3 id="_4-final" tabindex="-1"><a class="header-anchor" href="#_4-final" aria-hidden="true">#</a> 4.final</h3><p>什么是序列化？</p><p>序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。</p><p>“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”</p><p><strong>final类：</strong></p><p>“如果一个类使用了 final 关键字修饰，那么它就无法被继承.....”</p><p>“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。</p><p>“说得没毛病。”</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span><span class="token punctuation">,</span>
               <span class="token class-name">Constable</span><span class="token punctuation">,</span> <span class="token class-name">ConstantDesc</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>⚠️⚠️⚠️：String 是 immutable 类（不可变对象）</p><p>“那三妹你知道为什么 String 类要设计成 final 吗？”</p><p>“这个还真不知道。”三妹的表情透露出这种无奈。</p><p>“原因大致有 3 个。”</p><ul><li>为了实现字符串常量池的需要</li><li>为了线程安全的需要</li><li>为了 HashCode 的不可变性的需要</li></ul><p>“想了解更详细的原因，可以一会看看我之前写的这篇文章。”</p><p><a href="https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q" target="_blank" rel="noopener noreferrer">为什么 Java 字符串是不可变的？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_5-instanceof" tabindex="-1"><a class="header-anchor" href="#_5-instanceof" aria-hidden="true">#</a> 5.instanceof</h3><p>语法格式：</p><p><code>(object) instanceof (type)</code></p><p>​ 对象 类型</p><p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p><p>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如何使用？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 先判断类型</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 然后强制转换</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
    <span class="token comment">// 然后才能使用</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p><p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果类型匹配 直接使用 s</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="不可变对象" tabindex="-1"><a class="header-anchor" href="#不可变对象" aria-hidden="true">#</a> *不可变对象</h2><h3 id="_01、什么是不可变类" tabindex="-1"><a class="header-anchor" href="#_01、什么是不可变类" aria-hidden="true">#</a> 01、什么是不可变类？</h3><p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。</p><p>自从有了<strong>多线程</strong>，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把<strong>对象的状态变得混乱不堪</strong>。</p><p>引入关键字：synchronized(同步)</p><p>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。</p><p>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。</p><h3 id="_02、常见的不可变类" tabindex="-1"><a class="header-anchor" href="#_02、常见的不可变类" aria-hidden="true">#</a> 02、常见的不可变类</h3><p>String类</p><p>为什么要将String类设置为不可变类？</p><p>原因如下：</p><p>1）常量池的需要</p><p>字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><p>2）hashCode 的需要</p><p>因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。</p><p>3）线程安全</p><p>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。</p><p>因此，当我们调用 String 类的任何方法（比如说 <code>trim()</code>、<code>substring()</code>、<code>toLowerCase()</code>）时，总会返回一个新的对象，而不影响之前的值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> cmower <span class="token operator">=</span> &quot;沉默王二，一枚有趣的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="可变参数" tabindex="-1"><a class="header-anchor" href="#可变参数" aria-hidden="true">#</a> *可变参数</h2><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><h3 id="什么是泛型" tabindex="-1"><a class="header-anchor" href="#什么是泛型" aria-hidden="true">#</a> 什么是泛型</h3><blockquote><p>泛型：就是指在类定义时不会设置类中的属性或方法参数的具体类型，而是在类使用时（创建对象）再进行类型的定义。会在编译期检查类型是否错误。</p></blockquote><figure><img src="https://img-blog.csdnimg.cn/101412155b854d98891f6c0facdfde7f.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>类声明后的&lt;&gt;中这个T被称为类型参数，用于指代任意类型，实际上这个T只是个代表，写什么都可以。表示此时的value1，value2都是在类定义时没有明确类型，只有在使用时才告知编译器类型。出于规范，类型参数用单个的大写字母来代替，常见如下：</p><ul><li>T：代表任意类</li><li>E：表示Element的意思，或是异常</li><li>K：与V搭配使用</li><li>V：与K搭配使用</li></ul><p>以下内容来源于<a href="https://www.pdai.tech/md/java/basic/java-basic-x-generic.html" target="_blank" rel="noopener noreferrer">Java全栈体系<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>:</p><p><strong>通过泛型可以将不同数据类型的add()方法复用为一个方法：</strong></p><p><code>eg:</code>泛型add()方法：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>private static &lt;T extends Number&gt; double add(T a, T b) {
    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));
    return a.doubleValue() + b.doubleValue();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>看下这个例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;xxString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p><p>引入泛型，它将提供类型的约束，提供编译前的检查：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();

// list中只能放String, 不能放其它类型的元素
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更多内容请见：</p><p><a href="https://www.pdai.tech/md/java/basic/java-basic-x-generic.html" target="_blank" rel="noopener noreferrer">https://www.pdai.tech/md/java/basic/java-basic-x-generic.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h2><p>直接开始上实例：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>class A{
    public void test() {
        
    }
}

class B extends A{

    /**
        * 重载父类的test方法
        */
    @Override
    public void test() {
    }

    /**
        * 被弃用的方法
        */
    @Deprecated
    public void oldMethod() {
    }

    /**
        * 忽略告警
        * 
        * @return
        */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public List processList() {
        List list = new ArrayList();
        return list;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><h2 id="枚举-enum" tabindex="-1"><a class="header-anchor" href="#枚举-enum" aria-hidden="true">#</a> 枚举（enum）</h2><p><strong>定义：</strong></p><p>“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”</p><p>“我们来新建一个枚举 PlayerType。”</p><p>eg:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PlayerType</span> <span class="token punctuation">{</span>
    <span class="token constant">TENNIS</span><span class="token punctuation">,</span>
    <span class="token constant">FOOTBALL</span><span class="token punctuation">,</span>
    <span class="token constant">BASKETBALL</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>01 “既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。</p><p>eg:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">PlayerType</span> type<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PlayerType</span> <span class="token punctuation">{</span>
        <span class="token constant">TENNIS</span><span class="token punctuation">,</span>
        <span class="token constant">FOOTBALL</span><span class="token punctuation">,</span>
        <span class="token constant">BASKETBALL</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBasketballPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">BASKETBALL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">PlayerType</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> type<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setType</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>02 由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 <code>isBasketballPlayer()</code> 方法。</p><p>03 “枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。</p><p>04 “如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。</p><p>eg:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PlayerType</span> <span class="token punctuation">{</span>
    <span class="token function">TENNIS</span><span class="token punctuation">(</span><span class="token string">&quot;网球&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">FOOTBALL</span><span class="token punctuation">(</span><span class="token string">&quot;足球&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">BASKETBALL</span><span class="token punctuation">(</span><span class="token string">&quot;篮球&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    
    <span class="token class-name">PlayerType</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>05 “EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”</p><p>06 “因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-02.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>07 “除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”</p><p>08 “和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PlayerType</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> enumMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>09 有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/enum/enum-04.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PlayerType</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> enumMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">BASKETBALL</span><span class="token punctuation">,</span><span class="token string">&quot;篮球运动员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">FOOTBALL</span><span class="token punctuation">,</span><span class="token string">&quot;足球运动员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">TENNIS</span><span class="token punctuation">,</span><span class="token string">&quot;网球运动员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumMap<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">BASKETBALL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">BASKETBALL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">PlayerType</span><span class="token punctuation">.</span><span class="token constant">BASKETBALL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“来看一下输出结果。”</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}
篮球运动员
true
篮球运动员
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。</p><h3 id="单例-。。。" tabindex="-1"><a class="header-anchor" href="#单例-。。。" aria-hidden="true">#</a> 单例：。。。</h3><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2><p>何为正射？何为反射？</p><p>“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 <code>new</code> 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>Writer writer = new Writer();
writer.setName(&quot;沉默王二&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 <code>new</code> 关键字创建对象了。</p><p>我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为<strong>反射</strong>。</p><p>反射的缺点：</p><ul><li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li><li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。</li></ul><p>好处：</p><ul><li><strong>开发通用框架</strong>：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li><li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li><li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li></ul><p>详情参考：</p><p><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener noreferrer">浅析<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener noreferrer">深入理解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><blockquote><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。Java语言提供了反射机制，允许程序在运行时动态地获取类的信息，如类名、字段、方法、注解等，并且可以使用获取到的信息创建对象、调用方法、修改属性等操作。反射机制是Java语言的一种特性，也是很多框架和工具的核心实现。</p><p>反射机制的原理是基于Java虚拟机的动态性和类加载机制。在Java程序运行时，每个类都会被Java虚拟机加载到内存中，并生成一个Class对象，用于描述这个类的信息。通过Class对象可以获取类的所有信息，如类名、字段、方法、注解等。Java程序可以通过获取Class对象的方式来操作类的信息，这就是反射机制的基本原理。</p><p>在Java中，获取Class对象的方式有三种：</p><ol><li>使用类的.class属性获取Class对象</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Class&lt;?&gt; clazz = Person.class;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 2. 调用对象的getClass()方法获取Class对象</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Person person = new Person();
Class&lt;?&gt; clazz = person.getClass();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用Class.forName()方法获取Class对象</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Class&lt;?&gt; clazz = Class.forName(&quot;com.example.Person&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一旦获取了Class对象，就可以通过Class对象来获取类的信息和操作对象。例如，可以使用Class对象的getDeclaredFields()方法获取类的所有字段信息，并通过反射机制来修改字段的值；也可以使用Class对象的getDeclaredMethods()方法获取类的所有方法信息，并通过反射机制来调用方法。</p><p>需要注意的是，反射机制会对性能产生一定的影响，因为它需要在运行时动态地获取类的信息，而这种操作比编译时静态绑定的操作更耗时。因此，在需要高性能的场景下，最好避免使用反射机制。</p><p><strong>扩展：Class&lt;?&gt; clazz什么意思？</strong></p><p><code>Class&lt;?&gt; clazz</code> 是Java泛型的语法，其中<code>Class&lt;?&gt;</code>表示一个未知类型的Class对象，而clazz是一个变量名，可以根据需要进行修改。</p><p>这里的问号表示一个通配符，表示该变量可以接受任何类型的Class对象。这种语法被称为无限制通配符类型，它可以用来表示不确定类型的情况，比如获取一个未知类的Class对象。</p><p>需要注意的是，由于使用了通配符类型，编译器无法确定变量clazz的具体类型，因此在使用clazz时需要注意类型转换的问题。通常情况下，可以使用强制类型转换将clazz转换为具体的类型，例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Class&lt;?&gt; clazz = Person.class;
Person person = (Person) clazz.newInstance();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，clazz是一个Class&lt;?&gt;类型的变量，表示一个未知类型的Class对象，但是由于我们知道clazz对应的是Person类，因此可以将clazz强制转换为Person类型，然后使用反射机制创建Person对象。需要注意的是，由于newInstance()方法返回的是Object类型，因此需要将其强制转换为Person类型。</p></blockquote><h2 id="集合框架-容器" tabindex="-1"><a class="header-anchor" href="#集合框架-容器" aria-hidden="true">#</a> 集合框架（容器）</h2><p>集合框架的结构图：</p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png" alt="img" style="zoom:200%;"><p>单词：</p><p>Collection——集合；</p><p>Map——图、表（两个类间的映射关系）；</p><p>List——列举、列表；</p><p>Array——数组；</p><p>Arraylist——数组列表；</p><p>Linkedlist——链表；</p><p>Stack——栈； <code>执行效率较低</code></p><p>Vector——矩阵、模型 <code>线程安全</code></p><p>Java 集合框架可以分为两条大的支线：</p><ul><li>Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。</li><li>Map，代表键值对的集合，典型代表就是 HashMap。</li></ul><h3 id="_01、list" tabindex="-1"><a class="header-anchor" href="#_01、list" aria-hidden="true">#</a> 01、List</h3><blockquote><p>List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作</p></blockquote><h3 id="_02、set" tabindex="-1"><a class="header-anchor" href="#_02、set" aria-hidden="true">#</a> 02、Set</h3><p>说在前面：</p><p>Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？</p><p>因为 Map 的键不允许重复、无序吗</p><blockquote><p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同</p></blockquote><p>Set是Java中的<strong>集合类，提供了一种无顺序，不重复的集合</strong>。常用的子类包括HashSet, TreeSet等。</p><h3 id="_03、queue" tabindex="-1"><a class="header-anchor" href="#_03、queue" aria-hidden="true">#</a> 03、Queue</h3><blockquote><p>Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p></blockquote><h3 id="_04、map" tabindex="-1"><a class="header-anchor" href="#_04、map" aria-hidden="true">#</a> 04、Map</h3><blockquote><p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p></blockquote><h3 id="浅析arraylist-动态数组" tabindex="-1"><a class="header-anchor" href="#浅析arraylist-动态数组" aria-hidden="true">#</a> 浅析ArrayList（动态数组）</h3><p>arraylist是接口list的实现类，有很多方便调用的预定义方法，便于用户直接调用。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>List接口常用方法：
1、add(Object element)： 向列表的尾部添加指定的元素。
    /*
    	List&lt;String&gt; alist = new ArrayList&lt;&gt;();
    	alist.add(&quot;沉默王二&quot;);
	*/
2、size()： 返回列表中的元素个数。

3、get(int index)： 返回列表中指定位置的元素，index从0开始。

4、add(int index, Object element)： 在列表的指定位置插入指定元素。

5、set(int i, Object element)： 将索引i位置元素替换为元素element并返回被替换的元素。

6、clear()： 从列表中移除所有元素。

7、isEmpty()： 判断列表是否包含元素，不包含元素则返回 true，否则返回false。

8、contains(Object o)： 如果列表包含指定的元素，则返回 true。

9、remove(int index)： 移除列表中指定位置的元素，并返回被删元素。

10、remove(Object o)： 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。

11、iterator()： 返回按适当顺序在列表的元素上进行迭代的迭代器。  
    
12、indexof()：正序查找一个元素。倒叙查找为lastIndexOf()    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。</p><p>ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。</p><p>创建一个ArrayList的语法格式：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>ArrayList&lt;String&gt; alist = new ArrayList&lt;String&gt;();//标准
/*可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：*/
List&lt;String&gt; alist = new ArrayList&lt;&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。</p><p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p><h3 id="浅析linkedlist-链表" tabindex="-1"><a class="header-anchor" href="#浅析linkedlist-链表" aria-hidden="true">#</a> 浅析linkedList（链表）</h3><p>链表这门内功大致分为三个层次：</p><ul><li>第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；</li><li>第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li><li>第三层叫做“二叉树”，把后指针去掉，换成左右指针。</li></ul><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>创建一个LinkedList的语法格式：
LinkedList&lt;String&gt; list = new LinkedList();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>1）招式一：增</strong></p><p>可以调用 add 方法添加元素：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王四&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>add 方法内部其实调用的是 linkLast 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>linkLast，顾名思义，就是在链表的尾部链接：</p><ul><li>添加第一个元素的时候，first 和 last 都为 null。</li><li>然后新建一个节点 newNode，它的 prev 和 next 也为 null。</li><li>然后把 last 和 first 都赋值为 newNode。</li></ul><p>此时还不能称之为链表，因为前后节点都是断裂的。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-02.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>添加第二个元素的时候，first 和 last 都指向的是第一个节点。</li><li>然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。</li><li>然后把第一个节点的 next 赋值为 newNode。</li></ul><p>此时的链表还不完整。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-03.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。</li><li>然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。</li><li>然后把第二个节点的 next 赋值为 newNode。</li></ul><p>此时的链表已经完整了。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/linkedlist-04.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我这个增的招式，还可以演化成另外两个：</p><ul><li><code>addFirst()</code> 方法将元素添加到第一位；</li><li><code>addLast()</code> 方法将元素添加到末尾。</li></ul><p>addFirst 内部其实调用的是 linkFirst：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更新</p><p><strong>2）招式二：删</strong></p><p>我这个删的招式还挺多的：</p><ul><li><code>remove()</code>：删除第一个节点</li><li><code>remove(int)</code>：删除指定位置的节点</li><li><code>remove(Object)</code>：删除指定元素的节点</li><li><code>removeFirst()</code>：删除第一个节点</li><li><code>removeLast()</code>：删除最后一个节点</li></ul><p>remove 内部调用的是 removeFirst，所以这两个招式的功效一样。</p><p><code>remove(int)</code> 内部其实调用的是 unlink 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新为之前的 first。</p><p>unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。</p><p><strong>3）招式三：改</strong></p><p>可以调用 <code>set()</code> 方法来更新元素：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;沉默王五&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>来看一下 <code>set()</code> 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">E</span> oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先对指定的下标进行检查，看是否越界；然后根据下标查找原有的节点：</p><p><code>size &gt;&gt; 1</code>：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是二进制存储的。</p><p>换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。</p><p>找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。</p><p><strong>4）招式四：查</strong></p><p>我这个查的招式可以分为两种：</p><ul><li>indexOf(Object)：查找某个元素所在的位置</li><li>get(int)：查找某个位置上的元素</li></ul><p>indexOf 的内部分为两种，一种是元素为 null 的时候，必须使用 == 来判断；一种是元素为非 null 的时候，要使用 equals 来判断。因为 equals 是不能用来判 null 的，会抛出 NPE 错误。</p><p>get 方法的内核其实还是 node 方法，这个之前已经说明过了，这里略过。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实，查这个招式还可以演化为其他的一些，比如说：</p><ul><li><code>getFirst()</code> 方法用于获取第一个元素；</li><li><code>getLast()</code> 方法用于获取最后一个元素；</li><li><code>poll()</code> 和 <code>pollFirst()</code> 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；</li><li><code>pollLast()</code> 方法用于删除并返回最后一个元素；</li><li><code>peekFirst()</code> 方法用于返回但不删除第一个元素。</li></ul><p>虽然ArrayList经常喊LinkedList一声师弟，但二者之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。</p><p>比如说，我们俩在增删改查时候的时间复杂度。</p><h3 id="arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#arraylist和linkedlist的区别" aria-hidden="true">#</a> ArrayList和LinkedList的区别</h3><p>增删改查时候的时间复杂度。</p><p>由此，可以得出这样的结论：<strong>遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。</strong></p><h3 id="java中的iterator和iterable区别" tabindex="-1"><a class="header-anchor" href="#java中的iterator和iterable区别" aria-hidden="true">#</a> Java中的Iterator和Iterable区别</h3><p>Iterator：迭代器</p><p>Iterable：可迭代的</p><p>什么是迭代器？</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>迭代器 （iterator）有时又称 光标 （cursor）是**程序设计的 软件设计模式** ，可在容器对象（container，例如 链表 或 数组 ）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。

**中文名:** 迭代器

**外文名:** iterator
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。</p><p>第一种：for 循环。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;，&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种：迭代器。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Iterator</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;，&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三种：for-each。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">&quot;，&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fail-fast" tabindex="-1"><a class="header-anchor" href="#fail-fast" aria-hidden="true">#</a> fail-fast</h3><p>官翻：</p><div class="language-txet line-numbers-mode" data-ext="txet"><pre class="language-txet"><code>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system&#39;s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。——一种保护机制。</p><p>demo：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;一个文章真特么有趣的程序员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码看起来没有任何问题，但运行起来就报错了。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-01.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/fail-fast-02.png" alt="img" loading="lazy">那该如何正确地删除元素呢</strong>？</p><p><strong>1）remove 后 break</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;一个文章真特么有趣的程序员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 <code>checkForComodification</code> 方法不再执行了，所以异常也就不会抛出了。</p><p>但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。</p><p><strong>3）使用 Iterator</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默王三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;一个文章真特么有趣的程序员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> itr <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">String</span> str <span class="token operator">=</span> itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;沉默王二&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		itr<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。** 循环**</p><p>简单地总结一下，fail-fast 是一种保护机制，可以通过 for-each 循环删除集合的元素的方式验证这种保护机制。</p><p>那也就是说，for-each 本质上是一种语法糖，遍历集合时很方面，但并不适合拿来操作集合中的元素（增删）。</p><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h3><p>什么是hashmap？</p><p>说在前面：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>说到HashMap，就先说一下Map
map是用于存储键值对（&lt;key,value&gt;）的集合类，也可以说是一组键值对的映射（数学概念）。
Map的特点
1.没有重复的 key（一方面，key用set保存，所以key必须是唯一，无序的；另一方面，map的取值基本上是通过key来获取value，如果有两个相同的key，计算机将不知道到底获取哪个对应值；这时候有可能会问，那为什么我编程时候可以用put（）方法传入两个key值相同的键值对？那是因为源码中，传入key值相同的键值对，将作为覆盖处理）

2.每个 key 只能对应一个 value, 多个 key 可以对应一个 value（这就是映射的概念，最经典的例子就是射箭，一排射手，一排箭靶，一个射手只能射中一个箭靶，而每个箭靶可能被不同射手射中。这里每个射手只有一根箭，不存在三箭齐发还都中靶这种骚操作。将射手和射中的靶子连线，这根线加射手加靶子就是一个映射）

3.key,value 都可以是任何引用类型（包括 null）的数据（只能是引用类型）

4.Map 取代了古老的 Dictionary 抽象类（知道就行，可以忽略）
————————————————
版权声明：本文为CSDN博主「酒吧七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_36711757/article/details/80394272
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="一、hash-方法的原理" tabindex="-1"><a class="header-anchor" href="#一、hash-方法的原理" aria-hidden="true">#</a> 一、hash 方法的原理</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是***\*哈希值\****（hashCode），这种函数就叫做***\*哈希函数\****，而计算哈希值的过程就叫做***\*哈希\****。哈希的主要应用是哈希表和分布式缓存。

这里有个问题，哈希算法和哈希函数不是一个东西，哈希函数是哈希算法的一种实现，以后面试就说哈希函数就行。

在将键值对存入数组之前，将key通过哈希算法计算出哈希值，把哈希值作为数组下标，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做***\*哈希表\****，而这个存储位置就叫做***\*桶（bucket）\****。数组是通过整数下标直接访问元素，哈希表是通过字符串key直接访问元素，也就说哈希表是一种特殊的数组（关联数组），哈希表广泛应用于实现数据的快速查找（在map的key[集合](https://so.csdn.net/so/search?q=集合&amp;spm=1001.2101.3001.7020)中，一旦存储的key的数量特别多，那么在要查找某个key的时候就会变得很麻烦，数组中的key需要挨个比较，哈希的出现，使得这样的比较次数大大减少。）

哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是***\*哈希冲突（碰撞）\****。解决哈希冲突有两种方法，拉链法（链接法）和开放定址法（这种没用过）。***\*拉链法\****：将键值对对象封装为一个node结点，新增了next指向，这样就可以将碰撞的结点链接成一条单链表，保存在该地址（数组位置）中。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>key.hashCode()</code> 是用来获取键位的哈希值的，理论上，哈希值是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞的。</p><p>取模运算有两处。</p><blockquote><p>取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。<strong>取模</strong>主要是用于<strong>计算机术语</strong>中，<strong>取余</strong>则更多是<strong>数学概念</strong>。</p></blockquote><p>一处是往 HashMap 中 put 的时候（<code>putVal</code> 方法中）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
         n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一处是从 HashMap 中 get 的时候（<code>getNode</code> 方法中）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 <code>(n - 1) &amp; hash</code> 正是取模运算，就是把哈希值和（数组长度-1）做了一个“与”运算。</p><p>可能大家在疑惑：<strong>取模运算难道不该用 <code>%</code> 吗？为什么要用 <code>&amp;</code> 呢</strong>？</p><p>这是因为 <code>&amp;</code> 运算比 <code>%</code> 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p><blockquote><p>a % b = a &amp; (b-1)</p></blockquote><p>用 $2^n$ 替换下 b 就是：</p><blockquote><p>a % 2^n = a &amp; (2^n-1)</p></blockquote><p>综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p><p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞</strong>。</p><p><strong><a href="https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg" target="_blank" rel="noopener noreferrer">为什么 HashMap 的数组长度要取 2 的整次方?<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong></p><h4 id="二、扩容机制" tabindex="-1"><a class="header-anchor" href="#二、扩容机制" aria-hidden="true">#</a> 二、扩容机制</h4><p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 [ArrayList]这种“动态数组”，可以自动扩容。</p><p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素。</p><p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把小数组的元素复制过去。</p><p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树，比较复杂，为了便于理解，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，我们后面再详细说明 JDK 8 和 JDK 7 之间的区别。</p><h4 id="三、加载因子为什么是0-75" tabindex="-1"><a class="header-anchor" href="#三、加载因子为什么是0-75" aria-hidden="true">#</a> 三、加载因子为什么是0.75</h4><p>哈希函数计算结果越分散均匀，哈希碰撞的概率就越小，map的存取效率（时间复杂度）就会越高。</p><p>哈希表长度越长，空间成本越大，哈希函数计算结果越分散均匀。</p><p><em><strong>*扩容机制*</strong></em>（实际上就是负载因子）和哈希函数越合理，空间成本越小，哈希函数计算结果越分散均匀。</p><p>从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。</p><p>负载因子越大（长度一定），最大结点容量越大，resize次数越少，空间成本越小，map的存取效率就会越高。</p><p>桶数组初始容量（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高。</p><p>涉及到概率论的泊松分布与二项分布。</p><p><em><strong>引入红黑树的概念：</strong></em></p><p>这里存在一个问题，即使负载因子和哈希函数设计的再合理，也免不了会出现****拉链过长****（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p><h4 id="四、线程不安全" tabindex="-1"><a class="header-anchor" href="#四、线程不安全" aria-hidden="true">#</a> 四、线程不安全</h4><p>有何体现：</p><p>多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null，也就是环链死循环、数据丢失、数据覆盖三个问题。其中环链在JDK1.8已经解决，但还是有数据覆盖的问题。</p><p>究其根本：</p><p>线程不安全主要是发生在扩容函数中，即根源是在<strong>transfer函数</strong>中：transfer函数代码如下：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>/**
  *
  @version JDK1.7
  */
void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>HashMap</code>的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。</p><p>key 用 Set 存放，所以想做到 <strong>key 不允许重复</strong>，key 对应的类（一般是String）需要重写 hashCode 和 equals 方法</p><ul><li>HashMap不是同步，HashTable是同步的，但HashTable已经弃用，如果需要线程安全，可以用synchronizedMap，例如 Map m = Collections.synchronizedMap(new HashMap(...));</li></ul><h1 id="java-io" tabindex="-1"><a class="header-anchor" href="#java-io" aria-hidden="true">#</a> Java IO</h1><h2 id="关于字符编码" tabindex="-1"><a class="header-anchor" href="#关于字符编码" aria-hidden="true">#</a> 关于字符编码：</h2><p>通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。</p><figure><img src="https://gitee.com/WLei224/picgo/raw/master/shangtou-02.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_1-ascii" tabindex="-1"><a class="header-anchor" href="#_1-ascii" aria-hidden="true">#</a> <strong>1）ASCII</strong></h2><p>ASCII 码的局限在于只能显示 26 个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语，对于其他一些语言则无能无力，比如在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。</p><h2 id="_2-unicode" tabindex="-1"><a class="header-anchor" href="#_2-unicode" aria-hidden="true">#</a> <strong>2）Unicode</strong></h2><p>中文译作：万国码、国际码、统一码、单一码，就像它的名字都表示的，这是一种所有符号的编码。</p><p>一个字节只能表示 256 种符号，所以如果拿 ASCII 码来表示汉字的话，是远远不够用的，那就必须要用更多的字节。简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，理论上最多可以表示 256 x 256 = 65536 个符号。</p><p>曾有人这样说：</p><blockquote><p>Unicode 支持的字符上限是 65536 个，Unicode 字符必须占两个字节。</p></blockquote><p>但这是一种误解，记住，Unicode 只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节，所以它可以无穷大。</p><p>Unicode 虽然统一了全世界字符的编码，但没有规定如何存储。如果统一规定的话，每个符号就要用 3 个或 4 个字节表示，因为 2 个字节只能表示 65536 个，根本表示不全。</p><h2 id="_3-utf" tabindex="-1"><a class="header-anchor" href="#_3-utf" aria-hidden="true">#</a> <strong>3）UTF</strong></h2><p>UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p><p>也就是说，UTF-8 是一种可变长度的编码方式——这是它的优势也是劣势。(优势：包罗万象；劣势：造成空间资源浪费)</p><p>UTF-16 使用 2 个或者 4 个字节来存储字符。</p><ul><li>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。</li><li>对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储</li></ul><h2 id="_4-gb-2312" tabindex="-1"><a class="header-anchor" href="#_4-gb-2312" aria-hidden="true">#</a> <strong>4）GB 2312</strong></h2><p>中华人民共和国国家标准简体中文字符集。GB 2312 标准共收录 6763 个汉字（2 个字节就够用了），其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。</p><h2 id="_5-gbk" tabindex="-1"><a class="header-anchor" href="#_5-gbk" aria-hidden="true">#</a> <strong>5）GBK</strong></h2><p>虽然GB2312基本满足了汉字的计算机处理需求，但是，对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312 不能处理，就有了 GBK（K 为“扩展”的汉语拼音（kuòzhǎn）第一个声母）。</p><p>实例：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>// 输出 efbfbdefbfbd
System.out.println(HexUtil.encodeHex(&quot;��&quot;, Charset.forName(&quot;UTF-8&quot;)));
// 借助 hutool 转成二进制
byte[] testBytes = HexUtil.decodeHex(&quot;efbfbdefbfbd&quot;);
// 使用 GBK 解码
String testResult = new String(testBytes, Charset.forName(&quot;GBK&quot;));
// 输出锟斤拷
System.out.println(testResult);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，以后再见到<strong>锟斤拷</strong>，第一时间想到 UTF-8 和 GBK 的转换问题准没错</p><h2 id="_6-char" tabindex="-1"><a class="header-anchor" href="#_6-char" aria-hidden="true">#</a> <strong>6）char</strong></h2><p>引：为什么char用两个字节来表示？</p><p>答：在 Unicode 的设计之初，人们认为两个字节足以对世界上各种语言的所有字符进行编码，在 1991 年发布的 Unicode 1.0 中，仅用了 65536 个代码值中不到一半的部分。</p><p>所以，Java 决定采用 16 位的 Unicode 字符集。也就是说，当时的 char 类型可以表示任意一个 Unicode 字符。</p><p>随着Unicode 收录的字符越来越多，超过了 65536 个（2 个字节的最大表示范围）。超过的部分怎么办呢？只能用两个 char 来表示了。</p><p>在 Java 中，char 会占用两个字节，超出 char 的承受范围（&#39;\u0000&#39;（0）和 &#39;\uffff&#39;（65,535））的字符，都将无法表示。</p><p>实例： <code>𐐷</code> 字符，Unicode 编码是 <code>U+10437</code>，超过了65535</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">char</span> c1 <span class="token operator">=</span> &#39;\uD801\uDC37&#39;<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于超过65535的字符用char来表示时，它会被 IDEA 转成 UTF-16 十六进制字符代码 <code>\uD801\uDC37</code>（与此同时，编译器会提醒你最好把它声明成 String 类型）。</p><h1 id="jdk" tabindex="-1"><a class="header-anchor" href="#jdk" aria-hidden="true">#</a> jdk</h1><h2 id="什么是classpath" tabindex="-1"><a class="header-anchor" href="#什么是classpath" aria-hidden="true">#</a> 什么是classpath?</h2><p>​ <strong>结论1：在没有配置CLASSPATH环境变量时，java命令在找class文件时是默认在当前目录下寻找的。</strong></p><p>​ <strong>结论2：配置过CLASSPATH环境后，java命令是按照CLASSPATH变量中的路径来的寻找class文件的，这就是为什么CLASSPATH变量中配置没有当前目录时，即使当前目录中有class文件，java命令仍然不能正常运行的原因。</strong></p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/WLei224/WLei224.git/edit/master/docs/cainiao/javaessay.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1149630057@qq.com">WLei224</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/cainiao/hellovuepress.html" class="nav-link prev" aria-label="网站搭建过程记录"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->网站搭建过程记录</div></a><a href="/cainiao/Linux.html" class="nav-link next" aria-label="Linux常用命令"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Linux常用命令<!----></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/" target="_blank">豫ICP备2023001822号</a><img src="http://images.rl0206.love/202305030138722.png" height="15px" width="15px" /><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41078102000226"><span>豫公网安备 41078102000226号</span></a></div><div class="copyright">Copyright © 2023 WLei224</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-51c8bbd8.js" defer></script>
  </body>
</html>
