<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.4"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"paragraph","depth":1,"payload":{"lines":[1,5]},"content":"title: 思维导图<br>\nshortTitle: JAVA SE思维导图<br>\nsticky: true<br>\ncategory:"},{"type":"bullet_list","depth":1,"payload":{"lines":[5,13]},"content":"","children":[{"type":"list_item","depth":2,"payload":{"lines":[5,7]},"content":"面经<br>\ntag:"},{"type":"list_item","depth":2,"payload":{"lines":[7,10]},"content":"Java SE<br>\ndescription: 自己总结的Java SE面试导图<br>\nhead:"},{"type":"list_item","depth":2,"payload":{"lines":[10,13]},"content":"","children":[{"type":"list_item","depth":3,"payload":{"lines":[10,11]},"content":"meta"},{"type":"list_item","depth":3,"payload":{"lines":[11,13]},"content":"name: keywords<br>\ncontent: Java,Java SE,Java基础,Java教程,Java程序员进阶之路,Java入门,教程,复盘Java基础知识,Java随笔,复盘Java基础知识, 一份详细的Java面试基础知识, 一篇文章搞懂Java SE"}]}]},{"type":"heading","depth":1,"payload":{"lines":[14,15]},"content":"面试导图","children":[{"type":"heading","depth":2,"payload":{"lines":[16,17]},"content":"Java SE","children":[{"type":"heading","depth":3,"payload":{"lines":[18,19]},"content":"是什么（概念）","children":[{"type":"list_item","depth":4,"payload":{"lines":[20,21]},"content":"Java是一门面向对象的编程语言，继承了C<ins>的幼优点，舍弃了C</ins>的多继承与指针的难点，因此Java是一门功能强大且容易上手的编程语言。","children":[{"type":"list_item","depth":5,"payload":{"lines":[22,23]},"content":"Java是一门面向对象的编程语言，不仅吸收了C<ins>的优点，还舍弃了C</ins>的多继承与指针的难点，因此Java具有功能强大且容易上手的编程语言。"}]}]},{"type":"heading","depth":3,"payload":{"lines":[24,25]},"content":"怎么样（特点）","children":[{"type":"list_item","depth":4,"payload":{"lines":[26,27]},"content":"面向对象","children":[{"type":"list_item","depth":5,"payload":{"lines":[28,29]},"content":"封装、继承、多态"}]},{"type":"list_item","depth":4,"payload":{"lines":[30,31]},"content":"跨平台？原理","children":[{"type":"list_item","depth":5,"payload":{"lines":[32,33]},"content":"Write once，run anywhere"}]},{"type":"list_item","depth":4,"payload":{"lines":[34,35]},"content":"支持多线程","children":[{"type":"list_item","depth":5,"payload":{"lines":[36,37]},"content":"内置多线程机制，无需调用操作系统的多线程功能进行功能设计"}]},{"type":"list_item","depth":4,"payload":{"lines":[38,39]},"content":"编译与解释并存","children":[{"type":"list_item","depth":5,"payload":{"lines":[40,41]},"content":"高级编程语言按照程序的执行方式分为编译形和解释形，编译型就好比把外国文献先全部翻译再阅读，解释型就好比逐行翻译有，阅读后再翻译。为什么说Java是编译与解释并存？引文Java程序需要先编译成字节码.class文件，然后平台JVM将字节码解释成平台可识别的机器码，操作系统运行。","children":[{"type":"list_item","depth":6,"payload":{"lines":[42,43]},"content":"扩展：","children":[{"type":"list_item","depth":7,"payload":{"lines":[44,45]},"content":"动态类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[46,47]},"content":"只有在运行期间才会检查变量的数据类型，该类语言会在变量的第一次赋值时将数据类型记录下来。代表语言：Python、Ruby、PHP、JS"}]},{"type":"list_item","depth":7,"payload":{"lines":[48,49]},"content":"静态类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[50,51]},"content":"编译期间进行数据类型检查，不通过则无法运行。该类语言必须先声明数据类型，分配好内存空间。代表语言：C、C++、Java、Object-C"}]},{"type":"list_item","depth":7,"payload":{"lines":[52,53]},"content":"强类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[54,55]},"content":"含义：强制数据类型定义的语言，一旦变量声明，转换数据类型需要强制转换。代表语言：Java、C#、Python、Ruby、Object-C"}]},{"type":"list_item","depth":7,"payload":{"lines":[56,57]},"content":"弱类型语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[58,59]},"content":"含义：允许隐式类型转换，例如：int + float = float。代表语言：JS、PHP、C、C++"}]},{"type":"list_item","depth":7,"payload":{"lines":[60,61]},"content":"引申：编译型语言vs解释性语言","children":[{"type":"list_item","depth":8,"payload":{"lines":[62,63]},"content":"编译型语言有一个专门的编译过程，优点：运行时无需再次编译，执行效率高；缺点：依赖编译器，跨平台性差。"},{"type":"list_item","depth":8,"payload":{"lines":[63,64]},"content":"解释性语言运行前无需编译，优点：运行时逐行解释再运行，跨平台性好；缺点：执行效率低。注：语言都是解释性语言。"}]}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[65,66]},"content":"JVM、JDK、JRE的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[67,68]},"content":"jdk包含jre、jre包含jvm"}]},{"type":"list_item","depth":4,"payload":{"lines":[69,70]},"content":"字节码？什么好处","children":[{"type":"list_item","depth":5,"payload":{"lines":[71,72]},"content":"字节码是Java程序经过编译之后产生的。class文件，可以直接被jvm识别并运行，从而能够跨平台运行"}]}]},{"type":"heading","depth":3,"payload":{"lines":[73,74]},"content":"基础语法","children":[{"type":"list_item","depth":4,"payload":{"lines":[75,76]},"content":"数据类型","children":[{"type":"list_item","depth":5,"payload":{"lines":[77,78]},"content":"基本数据类型","children":[{"type":"list_item","depth":6,"payload":{"lines":[79,80]},"content":"整型","children":[{"type":"list_item","depth":7,"payload":{"lines":[81,82]},"content":"byte、short、int、long"}]},{"type":"list_item","depth":6,"payload":{"lines":[83,84]},"content":"浮点型","children":[{"type":"list_item","depth":7,"payload":{"lines":[85,86]},"content":"float、double"}]},{"type":"list_item","depth":6,"payload":{"lines":[87,88]},"content":"字符型","children":[{"type":"list_item","depth":7,"payload":{"lines":[89,90]},"content":"char"}]},{"type":"list_item","depth":6,"payload":{"lines":[91,92]},"content":"布尔型","children":[{"type":"list_item","depth":7,"payload":{"lines":[93,94]},"content":"boolean"}]}]},{"type":"list_item","depth":5,"payload":{"lines":[95,96]},"content":"引用数据类型","children":[{"type":"list_item","depth":6,"payload":{"lines":[97,98]},"content":"class"},{"type":"list_item","depth":6,"payload":{"lines":[98,99]},"content":"interface"},{"type":"list_item","depth":6,"payload":{"lines":[99,100]},"content":"数组"}]},{"type":"list_item","depth":5,"payload":{"lines":[101,102]},"content":"类型转换","children":[{"type":"list_item","depth":6,"payload":{"lines":[103,104]},"content":"自动转换","children":[{"type":"list_item","depth":7,"payload":{"lines":[105,106]},"content":"小杯水可以倒进大杯子，大杯水倒进小杯子就可能会溢出。案例1：float num1 = 1.2，在Java中float浮点型类型变量的声明要在数字的末尾加上f或F，否则属于双精度double类型，下转上会造成精度损失，正确写法：float num1 = 1.2F。"}]},{"type":"list_item","depth":6,"payload":{"lines":[107,108]},"content":"强制转换","children":[{"type":"list_item","depth":7,"payload":{"lines":[109,110]},"content":"对于上述解决方案，还可以进行强制类型转换：float num = (float)1.1;  案例2：short num2 = 1； num2  = num2 + 1;此时编译器会进行报错，我们一般的解决办法是进行强转，或者：short num2 = 1;  num2 += 1,这其实其中num2 += 1，有隐含的强制类型转换。"}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[111,112]},"content":"自动拆箱/装箱","children":[{"type":"list_item","depth":5,"payload":{"lines":[113,115]},"content":"装箱：Integer i = 10，把整型10装箱为Integer<br>\n拆箱：把i再赋值给int，int n = i；"}]},{"type":"list_item","depth":4,"payload":{"lines":[116,117]},"content":"运算符与位运算","children":[{"type":"list_item","depth":5,"payload":{"lines":[118,119]},"content":"&amp;","children":[{"type":"list_item","depth":6,"payload":{"lines":[120,121]},"content":"逻辑与（短路与：全1为1,有0为0）","children":[{"type":"list_item","depth":7,"payload":{"lines":[122,127]},"content":"算法引申：逻辑与可以用来判断奇偶数、是否为2的n次方的数，奇数的二进制末尾肯定为1，偶数的二进制末尾一定是0。例如：7(D) = 111(B), 所以7&amp;1 == 0。<br>\n结论：<br>\npublic static boolean check(int m){<br>\nreturn (m&amp;1)==1;<br>\n}"}]}]},{"type":"list_item","depth":5,"payload":{"lines":[128,129]},"content":"&amp;&amp;","children":[{"type":"list_item","depth":6,"payload":{"lines":[130,132]},"content":"短路与运算：跟&amp;差别很大：<br>\na == 1 &amp;&amp; b == 2，如果a == 1不成立，那么直接短路，右边不计算，很多时候都会用到","children":[{"type":"list_item","depth":7,"payload":{"lines":[133,134]},"content":"引申：| 与||","children":[{"type":"list_item","depth":8,"payload":{"lines":[135,136]},"content":"逻辑或（|）和短路（||）的差别亦是如此"}]}]}]},{"type":"list_item","depth":5,"payload":{"lines":[137,138]},"content":"<ins>a和a</ins>","children":[{"type":"list_item","depth":6,"payload":{"lines":[139,140]},"content":"涉及到JVM的工作原理：对于a<ins>来说，先创建一个临时变量，然后自增加1，若进行a = i</ins>赋值，a取到的是临时变量的值。"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[141,142]},"content":"语句特点","children":[{"type":"list_item","depth":5,"payload":{"lines":[143,144]},"content":"switch（电闸原理）作用域","children":[{"type":"list_item","depth":6,"payload":{"lines":[145,148]},"content":"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。<br>\n从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。<br>\n从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。"}]},{"type":"list_item","depth":5,"payload":{"lines":[149,150]},"content":"break、continue、return"}]}]},{"type":"heading","depth":3,"payload":{"lines":[153,154]},"content":"面向对象","children":[{"type":"list_item","depth":4,"payload":{"lines":[155,156]},"content":"面向对象与面向过程","children":[{"type":"list_item","depth":5,"payload":{"lines":[157,158]},"content":"面向对象：纪传体史记","children":[{"type":"list_item","depth":6,"payload":{"lines":[159,160]},"content":"典例：Java，万物皆对象，Java自带了许多封装好的方法，方便我们调用。面向对象加强了代码的重用，屏蔽差异性。"}]},{"type":"list_item","depth":5,"payload":{"lines":[161,162]},"content":"面向过程：编年体左转","children":[{"type":"list_item","depth":6,"payload":{"lines":[163,164]},"content":"典例：C，对于每一个功能，需要编写函数进行一步一步的实现。使用的时候再一步一步调用。"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[165,166]},"content":"三大特性","children":[{"type":"list_item","depth":5,"payload":{"lines":[167,168]},"content":"封装","children":[{"type":"list_item","depth":6,"payload":{"lines":[169,170]},"content":"封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。"}]},{"type":"list_item","depth":5,"payload":{"lines":[171,172]},"content":"继承","children":[{"type":"list_item","depth":6,"payload":{"lines":[173,174]},"content":"新的类可以继承已有的类，Class A extends Class B,A拥有B的所有属性与方法，但是无法访问私有属性"}]},{"type":"list_item","depth":5,"payload":{"lines":[175,176]},"content":"多态","children":[{"type":"list_item","depth":6,"payload":{"lines":[177,178]},"content":"多态的体现就在于继承与接口，可以实现同一个方法speak()被不同类型的对象调用，但是根据对象的实际类型，会产生不同的行为。","children":[{"type":"list_item","depth":7,"payload":{"lines":[179,194]},"content":"class Animal{<br>\npublic void speak(){<br>\nSyetem.out.println(&quot;动物叫&quot;);<br>\n}<br>\n}<br>\nclass cat extends Animal{<br>\npublic void speak{<br>\nSyetem.out.println(&quot;cat叫&quot;);<br>\n}<br>\n}<br>\nclass dog extends Animal{<br>\npublic void speak{<br>\nSyetem.out.println(&quot;dog叫&quot;);<br>\n}<br>\n}"}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[195,196]},"content":"重载与重写的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[197,198]},"content":"都是实现多态的方式：重载也叫方法重载，是同方法名，有着不同的参数，实现了不同的行为方法的我实现，例如实现不同数据类型的运算。"}]},{"type":"list_item","depth":4,"payload":{"lines":[199,200]},"content":"访问修饰符的区别","children":[{"type":"list_item","depth":5,"payload":{"lines":[201,202]},"content":"访问修饰符：public、protected、private"}]},{"type":"list_item","depth":4,"payload":{"lines":[203,204]},"content":"this关键字"},{"type":"list_item","depth":4,"payload":{"lines":[204,205]},"content":"抽象类和接口的区别"},{"type":"list_item","depth":4,"payload":{"lines":[205,206]},"content":"成员变量与局部变量的区别"},{"type":"list_item","depth":4,"payload":{"lines":[206,207]},"content":"静态变量与实例变量的区别"},{"type":"list_item","depth":4,"payload":{"lines":[207,208]},"content":"静态方法与实例方法的区别"},{"type":"list_item","depth":4,"payload":{"lines":[208,209]},"content":"final、finally、finalize关键字的作用"},{"type":"list_item","depth":4,"payload":{"lines":[209,210]},"content":"==和equals的区别"},{"type":"list_item","depth":4,"payload":{"lines":[210,211]},"content":"hashCode与equals"},{"type":"list_item","depth":4,"payload":{"lines":[211,212]},"content":"Java是值传递还是引用传递"},{"type":"list_item","depth":4,"payload":{"lines":[212,213]},"content":"深拷贝与浅拷贝"},{"type":"list_item","depth":4,"payload":{"lines":[213,214]},"content":"Java创建对象有几种方式"}]},{"type":"heading","depth":3,"payload":{"lines":[215,216]},"content":"String"},{"type":"heading","depth":3,"payload":{"lines":[217,218]},"content":"Integer"},{"type":"heading","depth":3,"payload":{"lines":[219,220]},"content":"Object"},{"type":"heading","depth":3,"payload":{"lines":[221,222]},"content":"异常处理"},{"type":"heading","depth":3,"payload":{"lines":[223,224]},"content":"I/O"},{"type":"heading","depth":3,"payload":{"lines":[225,226]},"content":"序列化"},{"type":"heading","depth":3,"payload":{"lines":[227,228]},"content":"泛型"},{"type":"heading","depth":3,"payload":{"lines":[229,230]},"content":"注解"},{"type":"heading","depth":3,"payload":{"lines":[231,232]},"content":"反射"},{"type":"heading","depth":3,"payload":{"lines":[233,234]},"content":"JDK8新特性"},{"type":"heading","depth":3,"payload":{"lines":[235,236]},"content":"Lambdb表达式"},{"type":"heading","depth":3,"payload":{"lines":[237,238]},"content":"Optional"},{"type":"heading","depth":3,"payload":{"lines":[239,240]},"content":"Stream流"}]},{"type":"heading","depth":2,"payload":{"lines":[241,242]},"content":"Java集合框架"},{"type":"heading","depth":2,"payload":{"lines":[243,244]},"content":"Java并发编程"},{"type":"heading","depth":2,"payload":{"lines":[245,246]},"content":"JVM"},{"type":"heading","depth":2,"payload":{"lines":[247,248]},"content":"Spring"},{"type":"heading","depth":2,"payload":{"lines":[249,250]},"content":"Redis"},{"type":"heading","depth":2,"payload":{"lines":[251,252]},"content":"分布式"},{"type":"heading","depth":2,"payload":{"lines":[253,254]},"content":"RocketMQ"},{"type":"heading","depth":2,"payload":{"lines":[255,256]},"content":"计算机网络"},{"type":"heading","depth":2,"payload":{"lines":[257,258]},"content":"操作系统"},{"type":"heading","depth":2,"payload":{"lines":[259,260]},"content":"MySQL"},{"type":"heading","depth":2,"payload":{"lines":[261,262]},"content":"MyBatis"}]}],"payload":{}},{})</script>
</body>
</html>
